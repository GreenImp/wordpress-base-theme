/**
 * Author: GreenImp Web
 * Date Created: 27/01/13 01:42
 */

if(typeof jQuery === 'undefined'){
	// jQuery is not defined
	throw new TypeError('jQuery is not defined', 'bill.js', 8);
}

(function($, window, document, undefined){
	'use strict';

	/**
	 * Base Bill Framework
	 */
	window.Bill = {
		name:'Bill-bootstrap',	// framework name
		version:'0.1.0',		// version number
		eventNameSpace:'.bill',	// namespace used for events
		libs:{},				// list of available libraries
		extensions:{},			// list of available plugins
		log:{},
		/**
		 * Initialises the Framework
		 *
		 * @param scope
		 * @param libraries
		 * @param method
		 * @param options
		 */
		init:function(scope, libraries, method, options){
			var libResponse = [];	// list of library load responses


			// reset the log
			this.log = {};

			// set global scope (used in the libraries)
			this.scope = scope || this.scope;

			if(libraries && (typeof libraries === 'string')){
				// split the libraries by space (to get each supplied library) and loop through them
				$.each(libraries.split(' '), function(i, lib){
					// add the library to the list
					libResponse.push(
						Bill.initLibrary(
							lib,
							[
								scope,
								(typeof method === 'object') ? method[lib] || method : method,
								(typeof options === 'object') ? options[lib] || options : options
							]
						)
					);
				});
			}else{
				// no libraries specified - load them all
				$.each(this.libs, function(name, lib){
					// add the library to the list
					libResponse.push(
						Bill.initLibrary(
							name,
							[
								scope,
								(typeof libraries === 'object') ? libraries[name] || libraries : libraries,
								(typeof method === 'object') ? method[name] || method : options
							]
						)
					);
				});

				/*if(typeof libraries === 'function'){
					// if the first argument is actually a callback (not library),
					// add to the arguments list
					args.unshift(libraries);
				}*/
			}

			// TODO - check responses
			console.log(this.log);
		},
		/**
		 * Initialises the given library
		 *
		 * @param lib
		 * @param args
		 * @returns {*}
		 */
		initLibrary:function(lib, args){
			return this.catchLib(function(){
				// check if the library exists
				if(this.libs.hasOwnProperty(lib)){
					// define the correct library scope
					this.libs[lib].scope = this.scope;

					// initialise the library and return
					return this.libs[lib].init.apply(this.libs[lib], args);
				}
			}.bind(this), lib);
		},
		/**
		 * Error handling for library loading
		 *
		 * @param func
		 * @param lib
		 * @returns {*}
		 */
		catchLib:function(func, lib){
			try{
				return func();
			}catch(e){
				return this.error({
					name:lib,
					message:'could not be initialized',
					file:'bill.js',
					line:97,
					e:e
				});
			}
		},
		error:function(e){
			// build the message
			var msg = e.name + ' ' + e.message +
						(e.e ? '; ' + e.e.name + ' ' + e.e.message : '') +
						(e.file ? '; ' + e.file + (e.line ? ' - ' + e.line : '') : '');

			// add the message to the log
			this.log.error = this.log.error || [];
			this.log.error.push(msg);

			// return the message
			return msg;
		},
		/**
		 * De-activates plugins
		 */
		off:function(){
			$(this.scope).off(this.eventNameSpace);
			$(window).off(this.eventNameSpace);
			$(document).off(this.eventNameSpace);
		}
	};

	/**
	 * Define Bill jQuery plugin
	 * @returns {*}
	 */
	$.fn.bill = function(){
		// get the arguments
		var args = Array.prototype.slice.call(arguments, 0);

		// loop through each element and apply Bill
		// return this, to retain chain-ability
		return this.each(function(){
			Bill.init.apply(Bill, [this].concat(args));
			return this;
		});
	};
})(jQuery, window, document);

/**
 * Basic functionality
 */
/**
 * Author: GreenImp
 * Date Created: 19/03/2013 10:44
 */

/**
 * jQuery extension functions
 */
$.extend({
	/**
	 * Adds jQuery function for getting the URL query strings.
	 * If `name` is defined, then it will return that named value
	 *
	 * @param name
	 * @returns {*}
	 */
	getQueryString:function(name){
		var queryString = window.location.search.substr(1);
		if(!queryString){
			// no query string
			return name ? null : {};
		}

		// check for a cached query string
		var cache = $(window).data('queryString');
		cache = $.extend(cache, {}); // ensure that the cache is an object

		if(!cache[queryString]){
			// no cache exists for the current query string

			// get the query string and split by &
			var queryVars = queryString.split('&'),
				arrayCheck = /^([^\[]+)((\[[^\]]*\])+)$/,
				arrayKeyCheck = /\[[^\]]*\]/g;

			// the query string variable
			cache[queryString] = {};

			// loop through each key=>value pair
			for(var i = 0; i < queryVars.length; i++){
				if(queryVars[i]){
					var variable = queryVars[i].split('='),
						key = decodeURIComponent(variable[0]),
						value = (typeof variable[1] == 'string') ? decodeURIComponent(variable[1].replace(/\+/g, ' ')) : undefined;

					// check if the key is an array
					if(arrayCheck.test(key)){
						// key is an array
						key = RegExp.$1;	// the key

						// ensure that they key is initialised as a variable of the cache
						cache[queryString][key] = cache[queryString][key] || {length: 0};

						var arrayNames = '',							// string of previous array key names
							arrays = RegExp.$2.match(arrayKeyCheck),	// list of array key names
							arrayLen = arrays.length;					// count of array key names
						// loop through the array key names and create the variables
						$.each(arrays, function(i, subKey){
							// determine the key name - if it is a string, we use it, if it is empty we calculate the numeric number, from the current array length
							subKey = (subKey && (subKey != '[]')) ? '"' + subKey.replace(/\[|\]/g, '') + '"' : eval('cache[queryString][key]' + arrayNames + '.length');

							// create the variable - I KNOW that using eval is horrible, but it's the best solution I could come up with quickly.
							eval('cache[queryString][key]' + arrayNames + '[' + subKey + '] = cache[queryString][key]' + arrayNames + '[' + subKey + '] || ' + ((i+1 == arrayLen) ? 'value' : '[]'));

							// add the array key to the list
							arrayNames += !isNaN(subKey) ? '' : '[' + subKey + ']';
						});

						//cache[queryString][key][RegExp.$2 ? RegExp.$2 : cache[queryString][key].length] = value;
						cache[queryString][key].length++;
					}else{
						cache[queryString][key] = value;
					}
				}
			}

			// cache the result
			$(window).data('queryString', cache);
		}

		return name ? cache[queryString][name] : cache[queryString];
	},
	/**
	 * Returns the viewport size
	 *
	 * @returns {{width: number, height: number}}
	 */
	viewport:{
		width:function(){
			return Math.max($(window).innerWidth(), window.innerWidth);
		},
		height:function(){
			return Math.max($(window).innerHeight(), window.innerHeight);
		},
		size:function(){
			return {
				width:this.width(),
				height:this.height()
			};
		},
		isSmall:function(){
			return this.width() <= 767;
		},
		isMedium:function(){
			var width = this.width();
			return (width > 767) && (width < 980);
		},
		isLarge:function(){
			return this.width() >= 980;
		}
	}
});

/**
 * Console failsafe, to stop errors when console is unavailable
 * http://paulirish.com/2008/graceful-degredation-of-your-firebug-specific-code/
 */
if(!('console' in window)){
	var names = [
		'assert',
		'count',
		'debug',
		'dir',
		'dirxml',
		'error',
		'group',
		'groupEnd',
		'info',
		'log',
		'profile',
		'profileEnd',
		'time',
		'timeEnd',
		'trace',
		'warn'
	];
    window.console = {};
    for(var i = 0; i < names.length; i++){
		window.console[names[i]] = function(){};
	}
}




/* ==========================================================================
 * String Functions
 * ========================================================================== */

/**
 * Allows padding of the string.
 * Default pad type is right.
 *
 * @param input
 * @param length
 * @param type
 * @returns {string}
 */
String.prototype.pad = function(input, length, type){
	if((type == 'l') || (type == 'left')){
		// pad left
		return (new Array(length+1).join(input)+this).slice(-length);
	}else{
		// pad type not left - assume right
		return (this+new Array(length+1).join(input)).slice(0,length);
	}
};

/**
 * Left pads the string
 *
 * @param input
 * @param length
 * @returns {string}
 */
String.prototype.lPad = function(input, length){
	return this.pad(input, length, 'l');
};

/**
 * Right pads the string
 *
 * @param input
 * @param length
 * @returns {string}
 */
String.prototype.rPad = function(input, length){
	return this.pad(input, length, 'r');
};


/**
 * Trims the string.
 * Default trim type is both.
 *
 * @param input
 * @param type
 * @returns {string}
 */
String.prototype.trim = function(input, type){
	input = input || '\s';
	type = ((type == 'l') || (type == 'left')) ? 'l' : (((type == 'r') || (type == 'right')) ? 'r' : 'b');

	return this.replace(new RegExp(((type != 'r') ? '^[' + input + ']+' : '') + ((type == 'b') ? '|' : '') + ((type != 'l') ? '[' + input + ']+$' : ''), 'g'), '');
};

/**
 * Left trims the string
 *
 * @param input
 * @returns {string}
 */
String.prototype.lTrim = function(input){
	return this.trim(input, 'l');
};

/**
 * Right trims the string
 *
 * @param input
 * @returns {string}
 */
String.prototype.rTrim = function(input){
	return this.trim(input, 'r');
};



/* ==========================================================================
 * Array Functions
 * ========================================================================== */

/*
 * Array max function,
 * returns the highest number, in the array
 *
 * Used like:
 *
 * `var myArray = [1, 10, 458, 12],
 * 	max = myArray.max();
 * console.log(max); // outputs 458`
 */
Array.prototype.max = function(){
	return Math.max.apply(null, this)
};

/*
 * Array min function,
 * returns the lowest number, in the array
 *
 * Used like:
 *
 * `var myArray = [1, 10, 458, 12],
 * 	min = myArray.min();
 * console.log(min); // outputs 1`
 */
Array.prototype.min = function(){
	return Math.min.apply(null, this)
};

/*
 * Array sum function,
 * returns the sum total of all values, in the array
 *
 * Used like:
 *
 * `var myArray = [1, 10, 458, 12],
 * 	sum = myArray.sum();
 * console.log(sum); // outputs 481`
 */
Array.prototype.sum = function(){
	var length = this.length,
	sum = 0;
	for(var i = 0; i < length; i++){
		sum += parseFloat(this[i]);
	}

	return sum;
};



/* ==========================================================================
 * Object Functions
 * ========================================================================== */

// check if browser supports Object.defineProperty
var hasDefineProperty = (typeof Object.defineProperty == 'function');
try{
	// try and add a property
	Object.defineProperty({}, 'propTest', {});
}catch(e){
	// adding property failed
	hasDefineProperty = false;
}

if(hasDefineProperty){
	/**
	 * Checks if the given object is equal
	 * to (same as) the current object.
	 *
	 * @param obj
	 * @returns {boolean}
	 */
	Object.defineProperty(Object.prototype, 'equals', {
		value:function(obj){
			var i;
			for(i in this){
				if(typeof(obj[i])=='undefined'){
					return false;
				}
			}

			for(i in this){
				if(this[i]){
					switch(typeof(this[i])){
						case 'object':
							if(!this[i].equals(obj[i])){
								return false;
							}
						break;
						case 'function':
							if(
								typeof(obj[i]) == 'undefined' ||
								(i != 'equals' && this[i].toString() != obj[i].toString())
							){
								return false;
							}
						break;
						default:
							if(this[i] != obj[i]){
								return false;
							}
						break;
					}
				}else{
					if (obj[i])
					return false;
				}
			}

			for(i in obj){
				if(typeof(this[i]) == 'undefined'){
					return false;
				}
			}

			return true;
		  }
	});
}


/**
 * Libraries
 */
/**
 * Bill.browserNotice
 *
 * Checks if the current browser is supported.
 * If not, a message is displayed to the user,
 * to alert them that they are using an out-dated
 * browser.
 *
 * Yes, browser sniffing is BAD, but sometimes you
 * seriously, just don't want to provide support
 * for a certain browser (IE 8<, for example).
 *
 * 'options' contains a list of browsers and the
 * earliest supported version number.
 * By default, ie support is set to 9.
 * All others have full support.
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.libs.browserNotice = {
		name:'Browser Notice',
		version:'0.1.0',
		options:{
			browsers:{
				ie:9,
				ff:null,
				chrome:null,
				safari:null,
				opera:null
			},
			animSpeed:600,
			message:'<p>It looks like you\'re using an outdated web browser. We don\'t support old browsers, as they have limited features and security issues.</p>' +
					'<p>You should consider upgrading.</p>',
			infoURL:'http://browsehappy.com/',
			closable:false,
			selectorID:'browserNotice'
		},
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			this.on();

			return true;
		},
		/**
		 * Activates the library
		 */
		on:function(){
			// only continue if the browser is not supported and the notice doesn't already exist
			if(!this.browserSupported() && !$('#' + this.selectorID).length){
				// browser not supported

				// build the browser notice
				$('<div id="' + this.options.selectorID + '" class="notice info fixed" data-notice>' +
					'<div class="container constrain">' +
						'<div class="row">' +
							'<div class="column ' + (this.options.infoURL ? 'eight' : 'twelve') + '">' +
								this.options.message +
							'</div>' +
							(
							this.options.infoURL ?
								'<div class="column four">' +
									'<a href="' + this.options.infoURL + '" title="Upgrade your browser" target="_blank" class="button">Find out more</a>' +
								'</div>'
								:
								''
							) +
						'</div>' +
					'</div>' +
					(this.options.closable ? '<a href="#close" class="closeBtn">X</a>' : '') +
				'</div>')
					// add the notice and slide it into view
					.prependTo('body')
					.hide()
					.slideDown(this.options.animSpeed);
			}
		},
		/**
		 * De-activates the library
		 */
		off:function(){
			$('#' + this.selectorID).remove();
		},
		/**
		 * Checks if the current browser is supported
		 * @returns {boolean}
		 */
		browserSupported:function(){
			if(typeof this.options.supported !== 'boolean'){
				var userAgent = navigator.userAgent,
					browsers = this.options.browsers;
				if(browsers.ie && !isNaN(browsers.ie) && (/MSIE (\d+\.\d+);/.test(userAgent))){
					// browser is IE
					if(parseFloat(RegExp.$1) < parseFloat(browsers.ie)){
						// version not supported
						this.options.supported = false;
					}
				}else if(browsers.ff && !isNaN(browsers.ff) && (/Firefox[\/\s](\d+\.\d+)/.test(userAgent))){
					// browser is Firefox
					if(parseFloat(RegExp.$1) < parseFloat(browsers.ff)){
						// version not supported
						this.options.supported = false;
					}
				}else if(browsers.chrome && !isNaN(browsers.chrome) && (/Chrome[\/\s](\d+\.\d+)/.test(userAgent))){
					// browser is Chrome
					if(parseFloat(RegExp.$1) < parseFloat(browsers.chrome)){
						// version not supported
						this.options.supported = false;
					}
				}else if(browsers.safari && !isNaN(browsers.safari) && (/Version[\/\s](\d+\.\d+)(.\d+)*\s+Safari/.test(userAgent))){
					// browser is Safari
					if(parseFloat(RegExp.$1) < parseFloat(browsers.safari)){
						// version not supported
						this.options.supported = false;
					}
				}else if(browsers.opera && !isNaN(browsers.opera) && (/Opera.*?Version[\/\s](\d+\.\d+)/.test(userAgent))){
					// browser is Opera
					if(parseFloat(RegExp.$1) < parseFloat(browsers.opera)){
						// version not supported
						this.options.supported = false;
					}
				}else{
					this.options.supported = true;
				}
			}

			return this.options.supported;
		}
	};
})(jQuery, window, document);
/**
 * Bill.cookieNotice
 *
 * Checks if the browser supports cookies.
 * If not, a message is displayed to the user.
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.libs.cookieNotice = {
		name:'Cookie Notice',
		version:'0.1.0',
		options:{
			animSpeed:600,
			message:'<p>' +
						'Your browser is blocking cookies. This website requires the use of cookies to work correctly.' +
					'</p>',
			infoURL:'http://www.whatarecookies.com/',
			closable:true,
			selectorID:'cookieNotice',
			enabled:true
		},
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			this.on();

			return true;
		},
		/**
		 * Activates the library
		 */
		on:function(){
			if(!this.cookiesEnabled() && !$('#' + this.options.selectorID).length){
				$('<div id="' + this.options.selectorID + '" class="notice info fixed" data-notice>' +
					'<div class="container constrain">' +
						'<div class="row">' +
							'<div class="column ' + (this.options.infoURL ? 'eight' : 'twelve') + '">' +
								this.options.message +
							'</div>' +
							(
							this.options.infoURL ?
								'<div class="column four">' +
									'<a href="' + this.options.infoURL + '" title="Find out more about cookies" target="_blank" class="button">Find out more</a>' +
								'</div>'
								:
								''
							) +
						'</div>' +
					'</div>' +
					(this.options.closable ? '<a href="#close" class="closeBtn">X</a>' : '') +
				'</div>')
					// add the notice and slide it into view
					.prependTo('body').hide().slideDown(this.options.animSpeed);
			}
		},
		/**
		 * De-activates the library
		 */
		off:function(){
			$('#' + this.options.selectorID).remove();
		},
		/**
		 * Checks if cookies are enabled, in the browser.
		 * Returns true if they are, otherwise false
		 *
		 * @returns {boolean}
		 */
		cookiesEnabled:function(){
			if(typeof this.options.supported !== 'boolean'){
				// base check for cookie functionality
				this.options.enabled = !!navigator.cookieEnabled;

				if(!this.options.enabled){
					// base check failed - try setting a cookie
					var cookieName = 'cookieTest';	// test cookie name

					document.cookie = cookieName;
					// check if the cookie was set
					this.options.enabled = (document.cookie.indexOf(cookieName) != -1);
				}
			}

			return this.options.enabled;
		}
	};
})(jQuery, window, document);

// UI functionality
/**
 * Bill.accordion
 *
 * Adds accordion functionality
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.libs.accordion = {
		name:'Accordion',
		version:'0.1.0',
		nameSpace:Bill.eventNameSpace + '.accordion',
		options:{
			animSpeed:200,
			animType:'slide',
			collapsible:false,
			accordion:true,
			titleSelector:'title',
			paneSelector:'pane'
		},
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			if(!this.options.init){
				var lib = this;

				this.on();

				$(this.scope).find('[data-accordion]').each(function(){
					var $elm = $(this),
						type = $elm.prop('tagName').toUpperCase(),	// get the 6accordion element type
						$titles,
						$panes;

					if(type == 'DL'){
						// for dl elements we look for `> dt` (for titles) and `> dd` (for panes)
						// we ignore `.title` and `.pane` classes, as dl elements already define their own title and data
						$titles = $elm.children('dt');

						if(!$titles.length){
							// no titles found
							Bill.error({
								name:lib.name,
								message:'No title elements found on bill.accordion object',
								file:'accordion.js',
								line:54
							});
							return;
						}

						// find the panes
						// loop through each title and find the next sibling
						// this will stop it from matching too many objects, as panes
						$titles.each(function(){
							var $pane = $(this).next('dd').addClass(lib.options.paneSelector);
							// add the pane to the list
							$panes = $panes ? $panes.add($pane) : $pane;
						});
					}else{
						var queryPrefixTitle = '',
							queryPrefixPane = '';

						if((type == 'UL') || (type == 'OL')){
							// for ul/ol elements, we look for `> li > .title/.pane` elements
							// add a title prefix to match within the direct li child
							queryPrefixTitle = 'li > ';
						}

						// we look for `> .title/.pane`
						// if none found, look for `> h{1-6}` (for titles) and direct sibling (for panes)
						$titles = $elm.find('> ' + queryPrefixTitle + '.' + lib.options.titleSelector);
						if(!$titles.length){
							// no titles found - check for h{1-6} elements

							// loop through until we find a heading tag - this gives us the highest number headers
							for(var i = 1; i <= 6; i++){
								$titles = $elm.find('> ' + queryPrefixTitle + 'h' + i);
								if($titles.length){
									// heading found - end the loop
									i = 7;
								}
							}

							if(!$titles.length){
								// still no titles found - end the element loop
								Bill.error({
									name:lib.name,
									message:'No title elements found on bill.accordion object',
									file:'accordion.js',
									line:98
								});
								return false;
							}
						}


						// find the panes
						// loop through each title
						$titles.each(function(){
							// add the pane to the list.
							// For the pane, we only match the element if it:
							// Has a class of `pane` or is a specific element type
							// and doesn't have a class of title
							var $pane = $(this)
								.next(
									queryPrefixPane + '.pane, ' +
										queryPrefixPane + 'div:not(.title), ' +
										queryPrefixPane + 'article:not(.title), ' +
										queryPrefixPane + 'section:not(.title), ' +
										queryPrefixPane + 'aside:not(.title)'
								)
								.addClass(lib.options.paneSelector);
							// add the pane to the list
							$panes = $panes ? $panes.add($pane) : $pane;
						});
					}

					$titles.addClass(lib.options.titleSelector);	// ensure that the titles have the `title` class

					if($panes && $panes.length){
						$panes.hide();	// hide all of the panes

						// if accordion is not collapsible, we must always have one pane open
						// trigger the click event on the first element
						if(!lib.options.collapsible){
							var animType = lib.options.animType,				// the current animation type
								activeTitle = $titles.filter('.active:first');	// check for a button with class 'active'
							// if no tab buttons have a class of active, just go with the first tab
							activeTitle = !activeTitle.length ? $titles.first() : activeTitle;

							// set no animation type, so that the tab appears immediately
							lib.options.animType = null;

							// trigger the click event
							activeTitle.click();

							// reset the animation type
							lib.options.animType = animType;
						}
					}
				});

				this.options.init = true;
			}

			return this.options.init;
		},
		/**
		 * Activates the plugin
		 */
		on:function(){
			var lib = this;

			/**
			 * Adds the click handler for title elements
			 */
			$(this.scope).on('click' + this.nameSpace, '[data-accordion] .' + lib.options.titleSelector, function(e){
				var $title = $(this),											// the title element
					$container = $title.closest('[data-accordion]'),			// the container element
					$pane = $title.next('.' + lib.options.paneSelector);		// the corresponding pane element

				if($title.hasClass('active')){
					// panel is already active - collapse, if we are allowed

					$pane.stop(true, true).show();

					if(lib.options.collapsible){
						// remove the active class from the title
						$title.removeClass('active');

						switch(lib.options.animType || 'show'){
							// animate
							case 'fade':
								$pane.fadeOut(lib.options.animSpeed);
							break;
							case 'slide':
								$pane.slideUp(lib.options.animSpeed);
							break;
							default:
								// no animation - just hide
								$pane.hide();
							break;
						}
					}
				}else{
					// panel not active

					// get a list of all the panes (and stop any animations)
					var $panes = $container.find('.' + lib.options.paneSelector).stop(true, true);

					if(lib.options.accordion){
						// this is a true accordion - remove active class on all titles
						$container.find('.' + lib.options.titleSelector).removeClass('active');
					}
					// add the active class to the current title
					$title.addClass('active');

					switch(lib.options.animType || 'show'){
						// animate
						case 'fade':
							if(lib.options.accordion){
								// true accordion - hide the other panes
								// we don't fade them out, otherwise it conflicts with
								// the position of the active pane
								$panes.hide();
							}
							$pane.fadeIn(lib.options.animSpeed);
						break;
						case 'slide':
							if(lib.options.accordion){
								// true accordion - hide the other panes
								$panes.not($pane).slideUp(lib.options.animSpeed);
							}
							$pane.slideDown(lib.options.animSpeed);
						break;
						default:
							// no animation - just show
							$panes.hide();
							$pane.show();
						break;
					}
				}

				// stop the default click event
				e.preventDefault();
			});
		},
		/**
		 * De-activates the plugin
		 */
		off:function(){
			$(this.scope).off(this.nameSpace);
		}
	};
})(jQuery, window, document);
/**
 * Bill.dialogue
 *
 * Replacement for default alert,
 * confirm and prompt dialogues
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.libs.dialogue = {
		name:'Dialogue',
		version:'0.1.0',
		nameSpace:Bill.eventNameSpace + '.dialogue',
		options:{
			animSpeed:400,
			type:'alert',
			msg:null,
			value:null,
			callback:null,
			buttons:[],
			dialogueID:'dialoguePopup'
		},
		buttonTemplate:{
			label:'button',
			value:true,
			'class':''
		},
		queue:[],
		active:false,
		init:function(scope, method, options){
			throw new Error(this.name + ' is currently not available, in this release of Bill.js', 'dialogue.js', 31);

			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			if(!this.options.init){
				this.on();
			}

			return this.options.init;
		},
		/**
		 * Activates the plugin
		 */
		on:function(){
			var lib = this,
				$scope = $(this.scope);

			/**
			 * Add the dialogue click handler
			 */
			$scope.on('click' + this.nameSpace, '[data-dialogue]', function(e){
				e.preventDefault();

				lib.doDialogue(lib.options);
			});

			if(lib.options.auto){
				// we need to auto-fire the dialogue
				$scope.triggerHandler('click' + this.nameSpace);
			}

			this.options.init = true;
		},
		/**
		 * De-activates the plugin
		 */
		off:function(){
			// clear the queue
			this.queue = [];
			// remove the click handler
			$(this.scope).off(this.nameSpace);
			$(window).off(this.nameSpace);
		},
		doDialogue:function(options){
			if(this.active){
				// dialogue already exists - add this to the queue
				this.queue.push(options);

				return true;
			}else if(!options.msg){
				// no message defined - we can't continue

				if($.isFunction(options.callback)){
					// we have a callback - trigger it, with a return value of null
					callback.apply(window, [null, null]);
				}

				return false;
			}


			// if we're here, then all is okay and we can create the alert box
			this.active = true;

			var lib = this,
				dialogueBox = $('<div id="' + this.options.dialogueID + '" class="dialogueBox float">' +	// the pop-up box
					'<div class="content"></div>' +
					'<div class="buttons"></div>' +
				'</div>'),
				overlay = $('#dialogueOverlay'),													// the overlay
				content = '',																		// the dialogue content
				buttonBox = dialogueBox.children('.buttons'),										// the button container
				buttonHTML = '';																	// the markup for outputting the buttons

			// if the overlay doesn't already exist, create it
			overlay = overlay.length ? overlay : $('<div id="dialogueOverlay"></div>');

			switch(options.type.toLowerCase()){
				case 'confirm':
					// confirmation dialogue
					dialogueBox.addClass('confirmation');
					content = '<p>' + options.msg + '</p>';

					options.buttons = [
						{
							label:'cancel',
							value:false,
							'class':'cancel'
						},
						{
							label:'OK',
							value:true,
							'class':'confirm'
						}
					];
				break;
				case 'prompt':
					// prompt dialogue
					dialogueBox.addClass('prompt');
					content = '<p>' + options.msg + '</p>' +
								'<input type="text" name="value" value="' + (options.value || '') + '"' + (options.placeholder ? ' placeholder="' + options.placeholder + '"' : '') + '>';

					options.buttons = [
						{
							label:'cancel',
							value:false,
							'class':'cancel'
						},
						{
							label:'OK',
							value:true,
							'class':'confirm'
						}
					];
				break;
				case 'alert':
					// alert dialogue
					dialogueBox.addClass('alert');
					content = '<p>' + options.msg + '</p>';

					options.buttons = [
						{
							label:'OK',
							value:true,
							'class':'confirm'
						}
					];
				break;
				default:
					// custom dialogue
					dialogueBox.addClass('custom');
					content = '<p>' + options.msg + '</p>' +
								(options.val ? '<input type="text" name="value" value="' + (options.value || '') + '"' + (options.placeholder ? ' placeholder="' + options.placeholder + '"' : '') + '>' : '');

					// loop through the buttons and ensure that they contain the correct data
					$.each(options.buttons, function(i, button){
						options.buttons[i] = $.extend({}, lib.buttonTemplate, button);
					});
				break;
			}

			// add the content to the pop-up
			dialogueBox.children('.content').html(content);

			// add any buttons to the pop-up
			$.each(options.buttons, function(){
				if(this.label){
					buttonHTML += '<button type="button" value="' + ((this.value === undefined) ? null : this.value) + '" class="' + (this['class'] || '') + '">' + this.label + '</button>';
				}
			});
			buttonBox.append(buttonHTML);


			// add the dialogue and set it's position
			dialogueBox
				.appendTo('body')					// add the dialogue box to the document body
				.css({margin:0, left:0, top:0})		// remove existing margin/positioning
				.css({								// add our own
					left:($(window).width()/2) - (dialogueBox.outerWidth()/2),
					top:($(window).height()/2) - (dialogueBox.outerHeight()/2)
				})
				.hide()
				.fadeIn(options.animSpeed);

			// add the overlay
			overlay.appendTo('body').stop(true, true).hide().fadeIn(options.animSpeed/2);

			/**
			 * re-position the dialogue when the screen size changes
			 */
			$(window).on('resize' + this.nameSpace, function(){
				dialogueBox
					.css({margin:0, left:0, top:0})		// remove existing margin/positioning
					.css({								// add our own
						left:($(window).width()/2) - (dialogueBox.outerWidth()/2),
						top:($(window).height()/2) - (dialogueBox.outerHeight()/2)
					});
			});


			// add click events for the buttons
			buttonBox.children('button').on('click' + this.nameSpace, function(e){
				e.preventDefault();

				// hide the dialogue box and remove it
				dialogueBox.stop(true, true).fadeOut(options.animSpeed, function(){
					dialogueBox.remove();

					// check the queue for our next dialogue
					if(lib.queue.length > 0){
						// next dialogue specified - trigger it
						lib.doDialogue(lib.queue.shift());
					}
				});

				// hide and remove the overlay
				overlay.fadeOut(options.animSpeed/2, function(){
					overlay.remove();
				});

				lib.active = false;

				// fire the callback function
				if($.isFunction(options.callback)){
					var btnVal = $(this).val(),
						inputVal = dialogueBox.find('> .content input[type=text][name=value]').val() || null;
					btnVal = (btnVal == 'true') ? true : ((btnVal == 'false') ? false : ((btnVal == 'null') ? null : btnVal));

					options.callback.apply(window, [btnVal, inputVal]);
				}
			});
		}
	};
})(jQuery, window, document);
/**
 * Bill.modal
 *
 * Shows modal dialogue boxes
 */
/*
 * FancyBox - jQuery Plugin
 * Simple and fancy lightbox alternative
 *
 * Examples and documentation at: http://fancybox.net
 *
 * Copyright (c) 2008 - 2010 Janis Skarnelis
 * That said, it is hardly a one-person project. Many people have submitted bugs, code, and offered their advice freely. Their support is greatly appreciated.
 *
 * Version: 1.3.4 (11/11/2010)
 * Requires: jQuery v1.3+
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

;(function($) {
	var tmp, loading, overlay, wrap, outer, content, close, title, nav_left, nav_right,

		selectedIndex = 0, selectedOpts = {}, selectedArray = [], currentIndex = 0, currentOpts = {}, currentArray = [],

		ajaxLoader = null, imgPreloader = new Image(), imgRegExp = /\.(jpg|gif|png|bmp|jpeg)(.*)?$/i, swfRegExp = /[^\.]\.(swf)\s*$/i,

		loadingTimer, loadingFrame = 1,

		titleHeight = 0, titleStr = '', start_pos, final_pos, busy = false, fx = $.extend($('<div/>')[0], { prop: 0 }),

		//isIE6 = $.browser.msie && $.browser.version < 7 && !window.XMLHttpRequest,
		isIE6 = navigator.userAgent.match(/msie/i) && navigator.userAgent.match(/6/) && !window.XMLHttpRequest,

		/*
		 * Private methods 
		 */

		_abort = function() {
			loading.hide();

			imgPreloader.onerror = imgPreloader.onload = null;

			if (ajaxLoader) {
				ajaxLoader.abort();
			}

			tmp.empty();
		},

		_error = function() {
			if (false === selectedOpts.onError(selectedArray, selectedIndex, selectedOpts)) {
				loading.hide();
				busy = false;
				return;
			}

			selectedOpts.titleShow = false;

			selectedOpts.width = 'auto';
			selectedOpts.height = 'auto';

			tmp.html( '<p id="fancybox-error">The requested content cannot be loaded.<br />Please try again later.</p>' );

			_process_inline();
		},

		_start = function() {
			var obj = selectedArray[ selectedIndex ],
				href, 
				type, 
				title,
				str,
				emb,
				ret;

			_abort();

			selectedOpts = $.extend({}, $.fn.fancybox.defaults, (typeof $(obj).data('fancybox') == 'undefined' ? selectedOpts : $(obj).data('fancybox')));

			ret = selectedOpts.onStart(selectedArray, selectedIndex, selectedOpts);

			if (ret === false) {
				busy = false;
				return;
			} else if (typeof ret == 'object') {
				selectedOpts = $.extend(selectedOpts, ret);
			}

			title = selectedOpts.title || (obj.nodeName ? $(obj).attr('title') : obj.title) || '';

			if (obj.nodeName && !selectedOpts.orig) {
				selectedOpts.orig = $(obj).children("img:first").length ? $(obj).children("img:first") : $(obj);
			}

			if (title === '' && selectedOpts.orig && selectedOpts.titleFromAlt) {
				title = selectedOpts.orig.attr('alt');
			}

			href = selectedOpts.href || (obj.nodeName ? $(obj).attr('href') : obj.href) || null;

			if ((/^(?:javascript)/i).test(href) || href == '#') {
				href = null;
			}

			if (selectedOpts.type) {
				type = selectedOpts.type;

				if (!href) {
					href = selectedOpts.content;
				}

			} else if (selectedOpts.content) {
				type = 'html';

			} else if (href) {
				if (href.match(imgRegExp)) {
					type = 'image';

				} else if (href.match(swfRegExp)) {
					type = 'swf';

				} else if ($(obj).hasClass("iframe")) {
					type = 'iframe';

				} else if (href.indexOf("#") === 0) {
					type = 'inline';

				} else {
					type = 'ajax';
				}
			}

			if (!type) {
				_error();
				return;
			}

			if (type == 'inline') {
				obj	= href.substr(href.indexOf("#"));
				type = $(obj).length > 0 ? 'inline' : 'ajax';
			}

			selectedOpts.type = type;
			selectedOpts.href = href;
			selectedOpts.title = title;

			if (selectedOpts.autoDimensions) {
				if (selectedOpts.type == 'html' || selectedOpts.type == 'inline' || selectedOpts.type == 'ajax') {
					selectedOpts.width = 'auto';
					selectedOpts.height = 'auto';
				} else {
					selectedOpts.autoDimensions = false;	
				}
			}

			if (selectedOpts.modal) {
				selectedOpts.overlayShow = true;
				selectedOpts.hideOnOverlayClick = false;
				selectedOpts.hideOnContentClick = false;
				selectedOpts.enableEscapeButton = false;
				selectedOpts.showCloseButton = false;
			}

			selectedOpts.padding = parseInt(selectedOpts.padding, 10);
			selectedOpts.margin = parseInt(selectedOpts.margin, 10);

			tmp.css('padding', (selectedOpts.padding + selectedOpts.margin));

			$('.fancybox-inline-tmp').unbind('fancybox-cancel').bind('fancybox-change', function() {
				$(this).replaceWith(content.children('div').children());
			});

			switch (type) {
				case 'html' :
					tmp.html( selectedOpts.content );
					_process_inline();
				break;

				case 'inline' :
					if ( $(obj).parent().is('#fancybox-content') === true) {
						busy = false;
						return;
					}

					$('<div class="fancybox-inline-tmp" />')
						.hide()
						.insertBefore( $(obj) )
						.bind('fancybox-cleanup', function() {
							$(this).replaceWith(content.children('div').children());
						}).bind('fancybox-cancel', function() {
							$(this).replaceWith(tmp.children('div').children());
						});

					$(obj).appendTo(tmp);

					_process_inline();
				break;

				case 'image':
					busy = false;

					$.fancybox.showActivity();

					imgPreloader = new Image();

					imgPreloader.onerror = function() {
						_error();
					};

					imgPreloader.onload = function() {
						busy = true;

						imgPreloader.onerror = imgPreloader.onload = null;

						_process_image();
					};

					imgPreloader.src = href;
				break;

				case 'swf':
					selectedOpts.scrolling = 'no';

					str = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" width="' + selectedOpts.width + '" height="' + selectedOpts.height + '"><param name="movie" value="' + href + '"></param>';
					emb = '';

					$.each(selectedOpts.swf, function(name, val) {
						str += '<param name="' + name + '" value="' + val + '"></param>';
						emb += ' ' + name + '="' + val + '"';
					});

					str += '<embed src="' + href + '" type="application/x-shockwave-flash" width="' + selectedOpts.width + '" height="' + selectedOpts.height + '"' + emb + '></embed></object>';

					tmp.html(str);

					_process_inline();
				break;

				case 'ajax':
					busy = false;

					$.fancybox.showActivity();

					selectedOpts.ajax.win = selectedOpts.ajax.success;

					ajaxLoader = $.ajax($.extend({}, selectedOpts.ajax, {
						url	: href,
						data : selectedOpts.ajax.data || {},
						error : function(XMLHttpRequest, textStatus, errorThrown) {
							if ( XMLHttpRequest.status > 0 ) {
								_error();
							}
						},
						success : function(data, textStatus, XMLHttpRequest) {
							var o = typeof XMLHttpRequest == 'object' ? XMLHttpRequest : ajaxLoader;
							if (o.status == 200) {
								if ( typeof selectedOpts.ajax.win == 'function' ) {
									ret = selectedOpts.ajax.win(href, data, textStatus, XMLHttpRequest);

									if (ret === false) {
										loading.hide();
										return;
									} else if (typeof ret == 'string' || typeof ret == 'object') {
										data = ret;
									}
								}

								tmp.html( data );
								_process_inline();
							}
						}
					}));

				break;

				case 'iframe':
					_show();
				break;
			}
		},

		_process_inline = function() {
			var
				w = selectedOpts.width,
				h = selectedOpts.height;

			if (w.toString().indexOf('%') > -1) {
				w = parseInt( ($(window).width() - (selectedOpts.margin * 2)) * parseFloat(w) / 100, 10) + 'px';

			} else {
				w = w == 'auto' ? 'auto' : w + 'px';	
			}

			if (h.toString().indexOf('%') > -1) {
				h = parseInt( ($(window).height() - (selectedOpts.margin * 2)) * parseFloat(h) / 100, 10) + 'px';

			} else {
				h = h == 'auto' ? 'auto' : h + 'px';	
			}

			tmp.wrapInner('<div style="width:' + w + ';height:' + h + ';overflow: ' + (selectedOpts.scrolling == 'auto' ? 'auto' : (selectedOpts.scrolling == 'yes' ? 'scroll' : 'hidden')) + ';position:relative;"></div>');

			selectedOpts.width = tmp.width();
			selectedOpts.height = tmp.height();

			_show();
		},

		_process_image = function() {
			selectedOpts.width = imgPreloader.width;
			selectedOpts.height = imgPreloader.height;

			$("<img />").attr({
				'id' : 'fancybox-img',
				'src' : imgPreloader.src,
				'alt' : selectedOpts.title
			}).appendTo( tmp );

			_show();
		},

		_show = function() {
			var pos, equal;

			loading.hide();

			if (wrap.is(":visible") && false === currentOpts.onCleanup(currentArray, currentIndex, currentOpts)) {
				//$.event.trigger('fancybox-cancel');
				$('.fancybox-inline-tmp').trigger('fancybox-cancel');

				busy = false;
				return;
			}

			busy = true;

			$(content.add( overlay )).unbind();

			$(window).unbind("resize.fb scroll.fb");
			$(document).unbind('keydown.fb');

			if (wrap.is(":visible") && currentOpts.titlePosition !== 'outside') {
				wrap.css('height', wrap.height());
			}

			currentArray = selectedArray;
			currentIndex = selectedIndex;
			currentOpts = selectedOpts;

			if (currentOpts.overlayShow) {
				overlay.css({
					'background-color' : currentOpts.overlayColor,
					'opacity' : currentOpts.overlayOpacity,
					'cursor' : currentOpts.hideOnOverlayClick ? 'pointer' : 'auto',
					'height' : $(document).height()
				});

				if (!overlay.is(':visible')) {
					if (isIE6) {
						$('select:not(#fancybox-tmp select)').filter(function() {
							return this.style.visibility !== 'hidden';
						}).css({'visibility' : 'hidden'}).one('fancybox-cleanup', function() {
							this.style.visibility = 'inherit';
						});
					}

					overlay.show();
				}
			} else {
				overlay.hide();
			}

			final_pos = _get_zoom_to();

			_process_title();

			if (wrap.is(":visible")) {
				$( close.add( nav_left ).add( nav_right ) ).hide();

				pos = wrap.position();

				start_pos = {
					top	 : pos.top,
					left : pos.left,
					width : wrap.width(),
					height : wrap.height()
				};

				equal = (start_pos.width == final_pos.width && start_pos.height == final_pos.height);

				content.fadeTo(currentOpts.changeFade, 0.3, function() {
					var finish_resizing = function() {
						content.html( tmp.contents() ).fadeTo(currentOpts.changeFade, 1, _finish);
					};

					//$.event.trigger('fancybox-change');
					$('.fancybox-inline-tmp').trigger('fancybox-change');

					content
						.empty()
						.removeAttr('filter')
						.css({
							'border-width' : currentOpts.padding,
							'width'	: final_pos.width - currentOpts.padding * 2,
							'height' : selectedOpts.autoDimensions ? 'auto' : final_pos.height - titleHeight - currentOpts.padding * 2
						});

					if (equal) {
						finish_resizing();

					} else {
						fx.prop = 0;

						$(fx).animate({prop: 1}, {
							 duration : currentOpts.changeSpeed,
							 easing : currentOpts.easingChange,
							 step : _draw,
							 complete : finish_resizing
						});
					}
				});

				return;
			}

			wrap.removeAttr("style");

			content.css('border-width', currentOpts.padding);

			if (currentOpts.transitionIn == 'elastic') {
				start_pos = _get_zoom_from();

				content.html( tmp.contents() );

				wrap.show();

				if (currentOpts.opacity) {
					final_pos.opacity = 0;
				}

				fx.prop = 0;

				$(fx).animate({prop: 1}, {
					 duration : currentOpts.speedIn,
					 easing : currentOpts.easingIn,
					 step : _draw,
					 complete : _finish
				});

				return;
			}

			if (currentOpts.titlePosition == 'inside' && titleHeight > 0) {	
				title.show();	
			}

			content
				.css({
					'width' : final_pos.width - currentOpts.padding * 2,
					'height' : selectedOpts.autoDimensions ? 'auto' : final_pos.height - titleHeight - currentOpts.padding * 2
				})
				.html( tmp.contents() );

			wrap
				.css(final_pos)
				.fadeIn( currentOpts.transitionIn == 'none' ? 0 : currentOpts.speedIn, _finish );
		},

		_format_title = function(title) {
			if (title && title.length) {
				/*if (currentOpts.titlePosition == 'float') {
					return '<table id="fancybox-title-float-wrap" cellpadding="0" cellspacing="0"><tr><td id="fancybox-title-float-left"></td><td id="fancybox-title-float-main">' + title + '</td><td id="fancybox-title-float-right"></td></tr></table>';
				}*/

				return '<div id="fancybox-title-' + currentOpts.titlePosition + '">' + title + '</div>';
			}

			return false;
		},

		_process_title = function() {
			titleStr = currentOpts.title || '';
			titleHeight = 0;

			title
				.empty()
				.removeAttr('style')
				.removeClass();

			if (currentOpts.titleShow === false) {
				title.hide();
				return;
			}

			titleStr = $.isFunction(currentOpts.titleFormat) ? currentOpts.titleFormat(titleStr, currentArray, currentIndex, currentOpts) : _format_title(titleStr);

			if (!titleStr || titleStr === '') {
				title.hide();
				return;
			}

			title
				.addClass('fancybox-title-' + currentOpts.titlePosition)
				.html( titleStr )
				.appendTo( 'body' )
				.show();

			switch (currentOpts.titlePosition) {
				case 'inside':
					title
						.css({
							'width' : final_pos.width - (currentOpts.padding * 2),
							'marginLeft' : currentOpts.padding,
							'marginRight' : currentOpts.padding
						});

					titleHeight = title.outerHeight(true);

					title.appendTo( outer );

					final_pos.height += titleHeight;
				break;

				case 'over':
					title
						.css({
							'marginLeft' : currentOpts.padding,
							'width'	: final_pos.width - (currentOpts.padding * 2),
							'bottom' : currentOpts.padding
						})
						.appendTo( outer );
				break;

				case 'float':
					title
						.css('left', parseInt((title.width() - final_pos.width - 40)/ 2, 10) * -1)
						.appendTo( wrap );
				break;

				default:
					title
						.css({
							'width' : final_pos.width - (currentOpts.padding * 2),
							'paddingLeft' : currentOpts.padding,
							'paddingRight' : currentOpts.padding
						})
						.appendTo( wrap );
				break;
			}

			title.hide();
		},

		_set_navigation = function() {
			if (currentOpts.enableEscapeButton || currentOpts.enableKeyboardNav) {
				$(document).bind('keydown.fb', function(e) {
					if (e.keyCode == 27 && currentOpts.enableEscapeButton) {
						e.preventDefault();
						$.fancybox.close();

					} else if ((e.keyCode == 37 || e.keyCode == 39) && currentOpts.enableKeyboardNav && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'SELECT') {
						e.preventDefault();
						$.fancybox[ e.keyCode == 37 ? 'prev' : 'next']();
					}
				});
			}

			if (!currentOpts.showNavArrows) {
				nav_left.hide();
				nav_right.hide();
				return;
			}

			if ((currentOpts.cyclic && currentArray.length > 1) || currentIndex !== 0) {
				nav_left.show();
			}

			if ((currentOpts.cyclic && currentArray.length > 1) || currentIndex != (currentArray.length -1)) {
				nav_right.show();
			}
		},

		_finish = function () {
			if (!$.support.opacity) {
				content.get(0).style.removeAttribute('filter');
				wrap.get(0).style.removeAttribute('filter');
			}

			if (selectedOpts.autoDimensions) {
				content.css('height', 'auto');
			}

			wrap.css('height', 'auto');

			if (titleStr && titleStr.length) {
				title.show();
			}

			if (currentOpts.showCloseButton) {
				close.show();
			}

			_set_navigation();

			if (currentOpts.hideOnContentClick)	{
				content.bind('click', $.fancybox.close);
			}

			if (currentOpts.hideOnOverlayClick)	{
				overlay.bind('click', $.fancybox.close);
			}

			$(window).bind("resize.fb", $.fancybox.resize);

			if (currentOpts.centerOnScroll) {
				$(window).bind("scroll.fb", $.fancybox.center);
			}

			if (currentOpts.type == 'iframe') {
				//$('<iframe id="fancybox-frame" name="fancybox-frame' + new Date().getTime() + '" frameborder="0" hspace="0" ' + ($.browser.msie ? 'allowtransparency="true""' : '') + ' scrolling="' + selectedOpts.scrolling + '" src="' + currentOpts.href + '"></iframe>').appendTo(content);
				$('<iframe id="fancybox-frame" name="fancybox-frame' + new Date().getTime() + '" frameborder="0" hspace="0" ' + (navigator.userAgent.match(/msie/i) ? 'allowtransparency="true""' : '') + ' scrolling="' + selectedOpts.scrolling + '" src="' + currentOpts.href + '"></iframe>').appendTo(content);
			}

			wrap.show();

			busy = false;

			$.fancybox.center();

			currentOpts.onComplete(currentArray, currentIndex, currentOpts);

			_preload_images();
		},

		_preload_images = function() {
			var href,
				objNext;

			if ((currentArray.length -1) > currentIndex) {
				href = currentArray[ currentIndex + 1 ].href;

				if (typeof href !== 'undefined' && href.match(imgRegExp)) {
					objNext = new Image();
					objNext.src = href;
				}
			}

			if (currentIndex > 0) {
				href = currentArray[ currentIndex - 1 ].href;

				if (typeof href !== 'undefined' && href.match(imgRegExp)) {
					objNext = new Image();
					objNext.src = href;
				}
			}
		},

		_draw = function(pos) {
			var dim = {
				width : parseInt(start_pos.width + (final_pos.width - start_pos.width) * pos, 10),
				height : parseInt(start_pos.height + (final_pos.height - start_pos.height) * pos, 10),

				top : parseInt(start_pos.top + (final_pos.top - start_pos.top) * pos, 10),
				left : parseInt(start_pos.left + (final_pos.left - start_pos.left) * pos, 10)
			};

			if (typeof final_pos.opacity !== 'undefined') {
				dim.opacity = pos < 0.5 ? 0.5 : pos;
			}

			wrap.css(dim);

			content.css({
				'width' : dim.width - currentOpts.padding * 2,
				'height' : dim.height - (titleHeight * pos) - currentOpts.padding * 2
			});
		},

		_get_viewport = function() {
			return [
				$(window).width() - (currentOpts.margin * 2),
				$(window).height() - (currentOpts.margin * 2),
				$(document).scrollLeft() + currentOpts.margin,
				$(document).scrollTop() + currentOpts.margin
			];
		},

		_get_zoom_to = function () {
			var view = _get_viewport(),
				to = {},
				resize = currentOpts.autoScale,
				double_padding = currentOpts.padding * 2,
				ratio;

			if (currentOpts.width.toString().indexOf('%') > -1) {
				to.width = parseInt((view[0] * parseFloat(currentOpts.width)) / 100, 10);
			} else {
				to.width = currentOpts.width + double_padding;
			}

			if (currentOpts.height.toString().indexOf('%') > -1) {
				to.height = parseInt((view[1] * parseFloat(currentOpts.height)) / 100, 10);
			} else {
				to.height = currentOpts.height + double_padding;
			}

			if (resize && (to.width > view[0] || to.height > view[1])) {
				if (selectedOpts.type == 'image' || selectedOpts.type == 'swf') {
					ratio = (currentOpts.width ) / (currentOpts.height );

					if ((to.width ) > view[0]) {
						to.width = view[0];
						to.height = parseInt(((to.width - double_padding) / ratio) + double_padding, 10);
					}

					if ((to.height) > view[1]) {
						to.height = view[1];
						to.width = parseInt(((to.height - double_padding) * ratio) + double_padding, 10);
					}

				} else {
					to.width = Math.min(to.width, view[0]);
					to.height = Math.min(to.height, view[1]);
				}
			}

			to.top = parseInt(Math.max(view[3] - 20, view[3] + ((view[1] - to.height - 40) * 0.5)), 10);
			to.left = parseInt(Math.max(view[2] - 20, view[2] + ((view[0] - to.width - 40) * 0.5)), 10);

			return to;
		},

		_get_obj_pos = function(obj) {
			var pos = obj.offset();

			pos.top += parseInt( obj.css('paddingTop'), 10 ) || 0;
			pos.left += parseInt( obj.css('paddingLeft'), 10 ) || 0;

			pos.top += parseInt( obj.css('border-top-width'), 10 ) || 0;
			pos.left += parseInt( obj.css('border-left-width'), 10 ) || 0;

			pos.width = obj.width();
			pos.height = obj.height();

			return pos;
		},

		_get_zoom_from = function() {
			var orig = selectedOpts.orig ? $(selectedOpts.orig) : false,
				from = {},
				pos,
				view;

			if (orig && orig.length) {
				pos = _get_obj_pos(orig);

				from = {
					width : pos.width + (currentOpts.padding * 2),
					height : pos.height + (currentOpts.padding * 2),
					top	: pos.top - currentOpts.padding - 20,
					left : pos.left - currentOpts.padding - 20
				};

			} else {
				view = _get_viewport();

				from = {
					width : currentOpts.padding * 2,
					height : currentOpts.padding * 2,
					top	: parseInt(view[3] + view[1] * 0.5, 10),
					left : parseInt(view[2] + view[0] * 0.5, 10)
				};
			}

			return from;
		},

		_animate_loading = function() {
			if (!loading.is(':visible')){
				clearInterval(loadingTimer);
				return;
			}

			$('div', loading).css('top', (loadingFrame * -40) + 'px');

			loadingFrame = (loadingFrame + 1) % 12;
		};

	/*
	 * Public methods
	 */

	$.fn.fancybox = function(options) {
		if (!$(this).length) {
			return this;
		}

		$(this)
			.data('fancybox', $.extend({}, options, ($.metadata ? $(this).metadata() : {})))
			.unbind('click.fb')
			.bind('click.fb', function(e) {
				e.preventDefault();

				if (busy) {
					return;
				}

				busy = true;

				$(this).blur();

				selectedArray = [];
				selectedIndex = 0;

				var rel = $(this).attr('rel') || '';

				if (!rel || rel == '' || rel === 'nofollow') {
					selectedArray.push(this);

				} else {
					//selectedArray = $("a[rel=" + rel + "], area[rel=" + rel + "]");
					selectedArray = $("a[rel=" + rel + "], area[rel=" + rel + "], img[rel=" + rel + "]");
					selectedIndex = selectedArray.index( this );
				}

				_start();

				return;
			});

		return this;
	};

	$.fancybox = function(obj) {
		var opts;

		if (busy) {
			return;
		}

		busy = true;
		opts = typeof arguments[1] !== 'undefined' ? arguments[1] : {};

		selectedArray = [];
		selectedIndex = parseInt(opts.index, 10) || 0;

		if ($.isArray(obj)) {
			for (var i = 0, j = obj.length; i < j; i++) {
				if (typeof obj[i] == 'object') {
					$(obj[i]).data('fancybox', $.extend({}, opts, obj[i]));
				} else {
					obj[i] = $({}).data('fancybox', $.extend({content : obj[i]}, opts));
				}
			}

			selectedArray = jQuery.merge(selectedArray, obj);

		} else {
			if (typeof obj == 'object') {
				$(obj).data('fancybox', $.extend({}, opts, obj));
			} else {
				obj = $({}).data('fancybox', $.extend({content : obj}, opts));
			}

			selectedArray.push(obj);
		}

		if (selectedIndex > selectedArray.length || selectedIndex < 0) {
			selectedIndex = 0;
		}

		_start();
	};

	$.fancybox.showActivity = function() {
		clearInterval(loadingTimer);

		loading.show();
		loadingTimer = setInterval(_animate_loading, 66);
	};

	$.fancybox.hideActivity = function() {
		loading.hide();
	};

	$.fancybox.next = function() {
		return $.fancybox.pos( currentIndex + 1);
	};

	$.fancybox.prev = function() {
		return $.fancybox.pos( currentIndex - 1);
	};

	$.fancybox.pos = function(pos) {
		if (busy) {
			return;
		}

		pos = parseInt(pos);

		selectedArray = currentArray;

		if (pos > -1 && pos < currentArray.length) {
			selectedIndex = pos;
			_start();

		} else if (currentOpts.cyclic && currentArray.length > 1) {
			selectedIndex = pos >= currentArray.length ? 0 : currentArray.length - 1;
			_start();
		}

		return;
	};

	$.fancybox.cancel = function() {
		if (busy) {
			return;
		}

		busy = true;

		//$.event.trigger('fancybox-cancel');
		$('.fancybox-inline-tmp').trigger('fancybox-cancel');

		_abort();

		selectedOpts.onCancel(selectedArray, selectedIndex, selectedOpts);

		busy = false;
	};

	// Note: within an iframe use - parent.$.fancybox.close();
	$.fancybox.close = function() {
		if (busy || wrap.is(':hidden')) {
			return;
		}

		busy = true;

		if (currentOpts && false === currentOpts.onCleanup(currentArray, currentIndex, currentOpts)) {
			busy = false;
			return;
		}

		_abort();

		$(close.add( nav_left ).add( nav_right )).hide();

		$(content.add( overlay )).unbind();

		$(window).unbind("resize.fb scroll.fb");
		$(document).unbind('keydown.fb');

		content.find('iframe').attr('src', isIE6 && /^https/i.test(window.location.href || '') ? 'javascript:void(false)' : 'about:blank');

		if (currentOpts.titlePosition !== 'inside') {
			title.empty();
		}

		wrap.stop();

		function _cleanup() {
			overlay.fadeOut('fast');

			title.empty().hide();
			wrap.hide();

			//$.event.trigger('fancybox-cleanup');
			$('.fancybox-inline-tmp').trigger('fancybox-cleanup');

			content.empty();

			currentOpts.onClosed(currentArray, currentIndex, currentOpts);

			currentArray = selectedOpts	= [];
			currentIndex = selectedIndex = 0;
			currentOpts = selectedOpts	= {};

			busy = false;
		}

		if (currentOpts.transitionOut == 'elastic') {
			start_pos = _get_zoom_from();

			var pos = wrap.position();

			final_pos = {
				top	 : pos.top ,
				left : pos.left,
				width :	wrap.width(),
				height : wrap.height()
			};

			if (currentOpts.opacity) {
				final_pos.opacity = 1;
			}

			title.empty().hide();

			fx.prop = 1;

			$(fx).animate({ prop: 0 }, {
				 duration : currentOpts.speedOut,
				 easing : currentOpts.easingOut,
				 step : _draw,
				 complete : _cleanup
			});

		} else {
			wrap.fadeOut( currentOpts.transitionOut == 'none' ? 0 : currentOpts.speedOut, _cleanup);
		}
	};

	$.fancybox.resize = function() {
		if (overlay.is(':visible')) {
			overlay.css('height', $(document).height());
		}

		$.fancybox.center(true);
	};

	$.fancybox.center = function() {
		var view, align;

		if (busy) {
			return;
		}

		align = arguments[0] === true ? 1 : 0;
		view = _get_viewport();

		if (!align && (wrap.width() > view[0] || wrap.height() > view[1])) {
			return;
		}

		wrap
			.stop()
			.animate({
				'top' : parseInt(Math.max(view[3] - 20, view[3] + ((view[1] - content.height() - 40) * 0.5) - currentOpts.padding)),
				'left' : parseInt(Math.max(view[2] - 20, view[2] + ((view[0] - content.width() - 40) * 0.5) - currentOpts.padding))
			}, typeof arguments[0] == 'number' ? arguments[0] : 200);
	};

	$.fancybox.init = function() {
		if ($("#fancybox-wrap").length) {
			return;
		}

		$('body').append(
			tmp	= $('<div id="fancybox-tmp"></div>'),
			loading	= $('<div id="fancybox-loading"><div></div></div>'),
			overlay	= $('<div id="fancybox-overlay"></div>'),
			wrap = $('<div id="fancybox-wrap"></div>')
		);

		outer = $('<div id="fancybox-outer"></div>')
			//.append('<div class="fancybox-bg" id="fancybox-bg-n"></div><div class="fancybox-bg" id="fancybox-bg-ne"></div><div class="fancybox-bg" id="fancybox-bg-e"></div><div class="fancybox-bg" id="fancybox-bg-se"></div><div class="fancybox-bg" id="fancybox-bg-s"></div><div class="fancybox-bg" id="fancybox-bg-sw"></div><div class="fancybox-bg" id="fancybox-bg-w"></div><div class="fancybox-bg" id="fancybox-bg-nw"></div>')
			.appendTo( wrap );

		outer.append(
			content = $('<div id="fancybox-content"></div>'),
			close = $('<a id="fancybox-close"></a>'),
			title = $('<div id="fancybox-title"></div>'),

			nav_left = $('<a href="javascript:;" id="fancybox-left"><span class="fancy-ico" id="fancybox-left-ico"></span></a>'),
			nav_right = $('<a href="javascript:;" id="fancybox-right"><span class="fancy-ico" id="fancybox-right-ico"></span></a>')
		);

		close.click($.fancybox.close);
		loading.click($.fancybox.cancel);

		nav_left.click(function(e) {
			e.preventDefault();
			$.fancybox.prev();
		});

		nav_right.click(function(e) {
			e.preventDefault();
			$.fancybox.next();
		});

		if ($.fn.mousewheel) {
			wrap.bind('mousewheel.fb', function(e, delta) {
				if (busy) {
					e.preventDefault();

				} else if ($(e.target).get(0).clientHeight == 0 || $(e.target).get(0).scrollHeight === $(e.target).get(0).clientHeight) {
					e.preventDefault();
					$.fancybox[ delta > 0 ? 'prev' : 'next']();
				}
			});
		}

		if (!$.support.opacity) {
			wrap.addClass('fancybox-ie');
		}

		if (isIE6) {
			loading.addClass('fancybox-ie6');
			wrap.addClass('fancybox-ie6');

			$('<iframe id="fancybox-hide-sel-frame" src="' + (/^https/i.test(window.location.href || '') ? 'javascript:void(false)' : 'about:blank' ) + '" scrolling="no" border="0" frameborder="0" tabindex="-1"></iframe>').prependTo(outer);
		}
	};

	$.fn.fancybox.defaults = {
		padding : 10,
		margin : 40,
		opacity : false,
		modal : false,
		cyclic : false,
		scrolling : 'auto',	// 'auto', 'yes' or 'no'

		width : 560,
		height : 340,

		autoScale : true,
		autoDimensions : true,
		centerOnScroll : false,

		ajax : {},
		swf : { wmode: 'transparent' },

		hideOnOverlayClick : true,
		hideOnContentClick : false,

		overlayShow : true,
		overlayOpacity : 0.7,
		overlayColor : '#777',

		titleShow : true,
		titlePosition : 'float', // 'float', 'outside', 'inside' or 'over'
		titleFormat : null,
		titleFromAlt : false,

		transitionIn : 'fade', // 'elastic', 'fade' or 'none'
		transitionOut : 'fade', // 'elastic', 'fade' or 'none'

		speedIn : 300,
		speedOut : 300,

		changeSpeed : 300,
		changeFade : 'fast',

		easingIn : 'swing',
		easingOut : 'swing',

		showCloseButton	 : true,
		showNavArrows : true,
		enableEscapeButton : true,
		enableKeyboardNav : true,

		onStart : function(){},
		onCancel : function(){},
		onComplete : function(){},
		onCleanup : function(){},
		onClosed : function(){},
		onError : function(){}
	};

	$(document).ready(function() {
		$.fancybox.init();
	});

})(jQuery);

;(function($, window, document, undefined){
	"use strict";

	Bill.libs.modal = {
		name:'Modal',
		version:'0.1.0',
		nameSpace:Bill.eventNameSpace + '.modal',
		options:{
			cyclic:true,
			titlePosition:'float'
		},
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			if(!this.options.init){
				this.on();
			}

			return this.options.init;
		},
		/**
		 * Activates the library
		 */
		on:function(){
			$(this.scope).find('[data-modal]').fancybox(this.options);

			this.options.init = true;
		},
		/**
		 * De-activates the library
		 */
		off:function(){}
	};
})(jQuery, window, document);
/**
 * Bill.navigation
 *
 * Handles navigation menus
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.libs.navigation = {
		name:'Navigation',
		version:'0.1.0',
		nameSpace:Bill.eventNameSpace + '.navigation',
		options:{
			animSpeed:200,
			backButton:'Back'
		},
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			if(!this.options.init){
				var lib = this;

				this.on();

				$(this.scope).find('[data-nav]').each(function(){
					var $elm = $(this);

					// wrap the contents with the 'inner' container
					$elm.addClass('dynamic').wrapInner('<div class="inner">');

					var $inner = $elm.children('div.inner:first'),	// get the 'inner' element
						$top = $('<div class="top">' +				// build the top bar
									'<span class="menuBtn">Menu</span>' +
								'</div>');

					// add the top bar to the nav to the nav
					$top.append($inner.children('.title')).prependTo($elm);

					// loop through all of the li elements and check if they have children
					$inner.find('li')
							.each(function(){
								var $item = $(this),					// the li element
									$children = $item.children('ul');	// any child ul elements
								if($children.length){
									// the item has sub-navigation
									$item.addClass('hasSub');	// apply hasSub class

									// add a back button to the sub-nav (used for small screens)
									$children.each(function(){
										var $child = $(this);
										if(!$child.children('.backBtn').length){
											$child.prepend('<li class="backBtn">' + ($elm.attr('data-text-back') || lib.options.backButton) + '</li>');
										}
									});
								}
							});
				});

				this.options.init = true;
			}

			return this.options.init;
		},
		/**
		 * Activates the plugin
		 */
		on:function(){
			var lib = this,
				$scope = $(this.scope);

			/**
			 * Handles click/swipes on elements that have sub navigation
			 */
			$scope.on('click' + this.nameSpace + ' swipeleft' + this.nameSpace, '[data-nav] li.hasSub', function(e){
				if($.viewport.isSmall() && !lib.animating){
					// we're on a small screen

					// check the clicked element - ensure that it's not a child of hasSub
					var $target = $(e.target),
						$elm = $target.closest('[data-nav]'),
						$inner = $elm.children('div.inner:first'),
						$top = $elm.children('div.top:first');

					if($target.hasClass('hasSub') || (($target.prop('tagName').toUpperCase() != 'UL') && $target.parent().hasClass('hasSub'))){
						// we're on an actual hasSub element

						var $parent = $(this),						// get the holder li element
							$subs = $parent.children('ul').show();	// get the sub nav and show it
						// ensure that we have a sub nav
						if($subs.length){
							lib.animating = true;

							$inner.find('li.active').removeClass('active');
							$parent.addClass('active');

							// set the nav container height to that of the sub navs
							$elm.height(lib.getHeight($subs, $top));

							// slide the sub nav into view
							var offset = (((parseFloat($inner.css('left')) / $elm.width()) * 100) - 100) + '%';
							$inner.stop(true, true).animate({left:offset}, lib.options.animSpeed, function(){
								lib.animating = false;
							});

							e.preventDefault();
						}
					}
				}

				e.stopPropagation();
			});

			/**
			 * Handles clicks/swipes on navigation back buttons
			 */
			$scope.on('click' + this.nameSpace + ' swiperight' + this.nameSpace, '[data-nav] li.backBtn', function(e){
				if($.viewport.isSmall() && !lib.animating){
					// we're on a small screen

					var $parent = $(this).closest('li.hasSub'),
						$elm = $parent.closest('[data-nav]'),
						$inner = $elm.children('div.inner:first'),
						$top = $elm.children('div.top:first');

					lib.animating = true;

					//$inner.find('li.active').removeClass('active');
					//$parent.parents('li.hasSub').addClass('active');
					$parent.removeClass('active');
					$parent.closest('li.hasSub').addClass('active');

					// set the nav container height to that of the parent nav's parent (so we show all of it's siblings too)
					$elm.height(lib.getHeight($parent.parent('ul').parent().children('ul'), $top));

					// slide the nav back to show the parent
					var offset = (((parseFloat($inner.css('left')) / $elm.width()) * 100) + 100);
					offset = (offset > 0) ? 0 : offset + '%';
					$inner.stop(true, true).animate({left:offset}, lib.options.animSpeed, function(){
						// hide the children (this stops them overlapping
						$parent.children('ul').hide();

						lib.animating = false;
					});

					e.preventDefault();
				}

				e.stopPropagation();
			});

			/**
			 * Click handler for the menu show/hide button
			 */
			$scope.on('click' + this.nameSpace, '[data-nav] > div.top span.menuBtn', function(e){
				if(typeof lib.options.menuOnClick === 'function'){
					// a callback function has been defined for the menu button click
					if(false === lib.options.menuOnClick.call($scope, $.viewport.isSmall())){
						// callback function returned false - end the event
						e.preventDefault();
						return false;
					}
				}

				if($.viewport.isSmall()){
					// we're on a small screen

					var $elm = $(this).closest('[data-nav]'),
						$inner = $elm.children('div.inner:first');

					if($elm.hasClass('active')){
						// nav is visible - hide it
						$elm.removeClass('active').height('auto');
						$inner.stop(true, true).slideUp(lib.options.animSpeed, function(){
							if(typeof lib.options.menuOnClickEnd === 'function'){
								// a callback function has been defined for the menu button click
								lib.options.menuOnClickEnd.call($scope, $elm);
							}
						});
					}else{
						// nav is hidden - show it
						$elm.addClass('active').height('auto');
						$inner.stop(true, true).css('left', 0).slideDown(lib.options.animSpeed, function(){
							if(typeof lib.options.menuOnClickEnd === 'function'){
								// a callback function has been defined for the menu button click
								lib.options.menuOnClickEnd.call($scope, $elm);
							}
						});
					}
				}

				e.preventDefault();
			});

			/**
			 * Ensure that the nav container is
			 * the correct height on small screens
			 */
			$(window).on('ready' + this.nameSpace + ' resize' + this.nameSpace, function(){
				var isSmall = $.viewport.isSmall();
				$('[data-nav]').each(function(){
					var $elm = $(this),
						$top = $elm.children('div.top:first'),
						$inner = $elm.children('div.inner:first');

					if(isSmall){
						// we're on a small screen

						// if nav is not active, hide the inner container
						if($elm.hasClass('active')){
							$inner.show();

							// define a fixed height on the nav
							$elm.height(lib.getHeight($inner.find('li.active:first').children('ul'), $top));
						}else{
							$inner.hide();
							$elm.height('auto');
						}
					}else{
						// we're not on a small screen - remove any style attributes
						$elm.removeAttr('style').removeClass('active');
						$inner
							.removeAttr('style')
							.find('ul')
								.removeAttr('style');
					}
				});
			});
		},
		/**
		 * De-activates the plugin
		 */
		off:function(){
			$(this.scope).off(this.nameSpace);
			$(window).off(this.nameSpace);
		},
		/**
		 * Returns the height of the element,
		 * including the height of $top
		 *
		 * @param $elm
		 * @param $top
		 * @returns {number}
		 */
		getHeight:function($elm, $top){
			var height = 0;
			// loop through all ul elements at the same level and calculate their height
			$elm.each(function(){
				height += $(this).outerHeight(true);
			});

			return height ? height + ($top.outerHeight() || 0) : 'auto';
		}
	};
})(jQuery, window, document);
/**
 * Bill.notice
 *
 * Adds ability to close notices
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.libs.notice = {
		name:'Notice',
		version:'0.1.0',
		nameSpace:Bill.eventNameSpace + '.notice',
		options:{
			animSpeed:400
		},
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			if(!this.options.init){
				this.on();
			}

			return this.options.init;
		},
		/**
		 * Activates the plugin
		 */
		on:function(){
			var lib = this;

			/**
			 * Add click handler for notice close buttons
			 */
			$(this.scope).on('click' + this.nameSpace, '[data-notice] a.closeBtn', function(e){
				e.preventDefault();

				// get the notice
				var $elm = $(this).closest('[data-notice]');
				if($elm.hasClass('fixed')){
					// this is a fixed notice - slide it up
					$elm.slideUp(lib.options.animSpeed, function(){
						$elm.remove();
					});
				}else{
					// this is a normal notice - fade it out
					$elm.fadeOut(lib.options.animSpeed, function(){
						$elm.remove();
					});
				}
			});

			this.options.init = true;
		},
		/**
		 * De-activates the plugin
		 */
		off:function(){
			$(this.scope).off(this.nameSpace);
		}
	};
})(jQuery, window, document);
/**
 * Bill.slider
 *
 * Image slider
 */

/**
 * BxSlider v4.1 - Fully loaded, responsive content slider
 * http://bxslider.com
 *
 * Copyright 2012, Steven Wanderski - http://stevenwanderski.com - http://bxcreative.com
 * Written while drinking Belgian ales and listening to jazz
 *
 * Released under the WTFPL license - http://sam.zoy.org/wtfpl/
 */

;(function($){

	var plugin = {};
	
	var defaults = {
		
		// GENERAL
		mode: 'horizontal',
		slideSelector: '',
		infiniteLoop: true,
		hideControlOnEnd: false,
		speed: 500,
		easing: null,
		slideMargin: 0,
		startSlide: 0,
		randomStart: false,
		captions: false,
		ticker: false,
		tickerHover: false,
		adaptiveHeight: false,
		adaptiveHeightSpeed: 500,
		video: false,
		useCSS: true,
		preloadImages: 'visible',

		// TOUCH
		touchEnabled: true,
		swipeThreshold: 50,
		oneToOneTouch: true,
		preventDefaultSwipeX: true,
		preventDefaultSwipeY: false,
		
		// PAGER
		pager: true,
		pagerType: 'full',
		pagerShortSeparator: ' / ',
		pagerSelector: null,
		buildPager: null,
		pagerCustom: null,
		
		// CONTROLS
		controls: true,
		nextText: 'Next',
		prevText: 'Prev',
		nextSelector: null,
		prevSelector: null,
		autoControls: false,
		startText: 'Start',
		stopText: 'Stop',
		autoControlsCombine: false,
		autoControlsSelector: null,
		
		// AUTO
		auto: false,
		pause: 4000,
		autoStart: true,
		autoDirection: 'next',
		autoHover: false,
		autoDelay: 0,
		
		// CAROUSEL
		minSlides: 1,
		maxSlides: 1,
		moveSlides: 0,
		slideWidth: 0,
		
		// CALLBACKS
		onSliderLoad: function() {},
		onSlideBefore: function() {},
		onSlideAfter: function() {},
		onSlideNext: function() {},
		onSlidePrev: function() {}
	}

	$.fn.bxSlider = function(options){
		
		if(this.length == 0) return this;
		
		// support mutltiple elements
		if(this.length > 1){
			this.each(function(){$(this).bxSlider(options)});
			return this;
		}
		
		// create a namespace to be used throughout the plugin
		var slider = {};
		// set a reference to our slider element
		var el = this;
		plugin.el = this;

		/**
		 * Makes slideshow responsive
		 */
		// first get the original window dimens (thanks alot IE)
		var windowWidth = $(window).width();
		var windowHeight = $(window).height();

		
		
		/**
		 * ===================================================================================
		 * = PRIVATE FUNCTIONS
		 * ===================================================================================
		 */
		
		/**
		 * Initializes namespace settings to be used throughout plugin
		 */
		var init = function(){
			// merge user-supplied options with the defaults
			slider.settings = $.extend({}, defaults, options);
			// parse slideWidth setting
			slider.settings.slideWidth = parseInt(slider.settings.slideWidth);
			// store the original children
			slider.children = el.children(slider.settings.slideSelector);
			// check if actual number of slides is less than minSlides / maxSlides
			if(slider.children.length < slider.settings.minSlides) slider.settings.minSlides = slider.children.length;
			if(slider.children.length < slider.settings.maxSlides) slider.settings.maxSlides = slider.children.length;
			// if random start, set the startSlide setting to random number
			if(slider.settings.randomStart) slider.settings.startSlide = Math.floor(Math.random() * slider.children.length);
			// store active slide information
			slider.active = { index: slider.settings.startSlide }
			// store if the slider is in carousel mode (displaying / moving multiple slides)
			slider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1;
			// if carousel, force preloadImages = 'all'
			if(slider.carousel) slider.settings.preloadImages = 'all';
			// calculate the min / max width thresholds based on min / max number of slides
			// used to setup and update carousel slides dimensions
			slider.minThreshold = (slider.settings.minSlides * slider.settings.slideWidth) + ((slider.settings.minSlides - 1) * slider.settings.slideMargin);
			slider.maxThreshold = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
			// store the current state of the slider (if currently animating, working is true)
			slider.working = false;
			// initialize the controls object
			slider.controls = {};
			// initialize an auto interval
			slider.interval = null;
			// determine which property to use for transitions
			slider.animProp = slider.settings.mode == 'vertical' ? 'top' : 'left';
			// determine if hardware acceleration can be used
			slider.usingCSS = slider.settings.useCSS && slider.settings.mode != 'fade' && (function(){
				// create our test div element
				var div = document.createElement('div');
				// css transition properties
				var props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
				// test for each property
				for(var i in props){
					if(div.style[props[i]] !== undefined){
						slider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();
						slider.animProp = '-' + slider.cssPrefix + '-transform';
						return true;
					}
				}
				return false;
			}());
			// if vertical mode always make maxSlides and minSlides equal
			if(slider.settings.mode == 'vertical') slider.settings.maxSlides = slider.settings.minSlides;
			// perform all DOM / CSS modifications
			setup();
		}

		/**
		 * Performs all DOM and CSS modifications
		 */
		var setup = function(){
			// wrap el in a wrapper
			el.wrap('<div class="bx-wrapper"><div class="bx-viewport"></div></div>');
			// store a namspace reference to .bx-viewport
			slider.viewport = el.parent();
			// add a loading div to display while images are loading
			slider.loader = $('<div class="bx-loading" />');
			slider.viewport.prepend(slider.loader);
			// set el to a massive width, to hold any needed slides
			// also strip any margin and padding from el
			el.css({
				width: slider.settings.mode == 'horizontal' ? slider.children.length * 215 + '%' : 'auto',
				position: 'relative'
			});
			// if using CSS, add the easing property
			if(slider.usingCSS && slider.settings.easing){
				el.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);
			// if not using CSS and no easing value was supplied, use the default JS animation easing (swing)
			}else if(!slider.settings.easing){
				slider.settings.easing = 'swing';
			}
			var slidesShowing = getNumberSlidesShowing();
			// make modifications to the viewport (.bx-viewport)
			slider.viewport.css({
				width: '100%',
				overflow: 'hidden',
				position: 'relative'
			});
			slider.viewport.parent().css({
				maxWidth: getViewportMaxWidth()
			});
			// apply css to all slider children
			slider.children.css({
				'float': slider.settings.mode == 'horizontal' ? 'left' : 'none',
				listStyle: 'none',
				position: 'relative'
			});
			// apply the calculated width after the float is applied to prevent scrollbar interference
			slider.children.width(getSlideWidth());
			// if slideMargin is supplied, add the css
			if(slider.settings.mode == 'horizontal' && slider.settings.slideMargin > 0) slider.children.css('marginRight', slider.settings.slideMargin);
			if(slider.settings.mode == 'vertical' && slider.settings.slideMargin > 0) slider.children.css('marginBottom', slider.settings.slideMargin);
			// if "fade" mode, add positioning and z-index CSS
			if(slider.settings.mode == 'fade'){
				slider.children.css({
					position: 'absolute',
					zIndex: 0,
					display: 'none'
				});
				// prepare the z-index on the showing element
				slider.children.eq(slider.settings.startSlide).css({zIndex: 50, display: 'block'});
			}
			// create an element to contain all slider controls (pager, start / stop, etc)
			slider.controls.el = $('<div class="bx-controls" />');
			// if captions are requested, add them
			if(slider.settings.captions) appendCaptions();
			// if infinite loop, prepare additional slides
			if(slider.settings.infiniteLoop && slider.settings.mode != 'fade' && !slider.settings.ticker){
				var slice = slider.settings.mode == 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides;
				var sliceAppend = slider.children.slice(0, slice).clone().addClass('bx-clone');
				var slicePrepend = slider.children.slice(-slice).clone().addClass('bx-clone');
				el.append(sliceAppend).prepend(slicePrepend);
			}
			// check if startSlide is last slide
			slider.active.last = slider.settings.startSlide == getPagerQty() - 1;
			// if video is true, set up the fitVids plugin
			if(slider.settings.video) el.fitVids();
			// set the default preload selector (visible)
			var preloadSelector = slider.children.eq(slider.settings.startSlide);
			if (slider.settings.preloadImages == "all") preloadSelector = el.children();
			// only check for control addition if not in "ticker" mode
			if(!slider.settings.ticker){
				// if pager is requested, add it
				if(slider.settings.pager) appendPager();
				// if controls are requested, add them
				if(slider.settings.controls) appendControls();
				// if auto is true, and auto controls are requested, add them
				if(slider.settings.auto && slider.settings.autoControls) appendControlsAuto();
				// if any control option is requested, add the controls wrapper
				if(slider.settings.controls || slider.settings.autoControls || slider.settings.pager) slider.viewport.after(slider.controls.el);
			// if ticker mode, do not allow a pager
			}else{
				slider.settings.pager = false;
			}
			// preload all images, then perform final DOM / CSS modifications that depend on images being loaded
			preloadSelector.imagesLoaded(start);
		}

		/**
		 * Start the slider
		 */
		var start = function(){
			// remove the loading DOM element
			slider.loader.remove();
			// set the left / top position of "el"
			setSlidePosition();
			// if "vertical" mode, always use adaptiveHeight to prevent odd behavior
			if (slider.settings.mode == 'vertical') slider.settings.adaptiveHeight = true;
			// set the viewport height
			slider.viewport.height(getViewportHeight());
			// make sure everything is positioned just right (same as a window resize)
			el.redrawSlider();
			// onSliderLoad callback
			slider.settings.onSliderLoad(slider.active.index);
			// slider has been fully initialized
			slider.initialized = true;
			// bind the resize call to the window
			$(window).bind('resize', resizeWindow);
			// if auto is true, start the show
			if (slider.settings.auto && slider.settings.autoStart) initAuto();
			// if ticker is true, start the ticker
			if (slider.settings.ticker) initTicker();
			// if pager is requested, make the appropriate pager link active
			if (slider.settings.pager) updatePagerActive(slider.settings.startSlide);
			// check for any updates to the controls (like hideControlOnEnd updates)
			if (slider.settings.controls) updateDirectionControls();
			// if touchEnabled is true, setup the touch events
			if (slider.settings.touchEnabled && !slider.settings.ticker) initTouch();
		}
		
		/**
		 * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value
		 */
		var getViewportHeight = function(){
			var height = 0;
			// first determine which children (slides) should be used in our height calculation
			var children = $();
			// if mode is not "vertical" and adaptiveHeight is false, include all children
			if(slider.settings.mode != 'vertical' && !slider.settings.adaptiveHeight){
				children = slider.children;
			}else{
				// if not carousel, return the single active child
				if(!slider.carousel){
					children = slider.children.eq(slider.active.index);
				// if carousel, return a slice of children
				}else{
					// get the individual slide index
					var currentIndex = slider.settings.moveSlides == 1 ? slider.active.index : slider.active.index * getMoveBy();
					// add the current slide to the children
					children = slider.children.eq(currentIndex);
					// cycle through the remaining "showing" slides
					for (i = 1; i <= slider.settings.maxSlides - 1; i++){
						// if looped back to the start
						if(currentIndex + i >= slider.children.length){
							children = children.add(slider.children.eq(i - 1));
						}else{
							children = children.add(slider.children.eq(currentIndex + i));
						}
					}
				}
			}
			// if "vertical" mode, calculate the sum of the heights of the children
			if(slider.settings.mode == 'vertical'){
				children.each(function(index) {
				  height += $(this).outerHeight();
				});
				// add user-supplied margins
				if(slider.settings.slideMargin > 0){
					height += slider.settings.slideMargin * (slider.settings.minSlides - 1);
				}
			// if not "vertical" mode, calculate the max height of the children
			}else{
				height = Math.max.apply(Math, children.map(function(){
					return $(this).outerHeight(false);
				}).get());
			}
			return height;
		}

		/**
		 * Returns the calculated width to be used for the outer wrapper / viewport
		 */
		var getViewportMaxWidth = function(){
			var width = '100%';
			if(slider.settings.slideWidth > 0){
				if(slider.settings.mode == 'horizontal'){
					width = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
				}else{
					width = slider.settings.slideWidth;
				}
			}
			return width;
		}
		
		/**
		 * Returns the calculated width to be applied to each slide
		 */
		var getSlideWidth = function(){
			// start with any user-supplied slide width
			var newElWidth = slider.settings.slideWidth;
			// get the current viewport width
			var wrapWidth = slider.viewport.width();
			// if slide width was not supplied, or is larger than the viewport use the viewport width
			if(slider.settings.slideWidth == 0 ||
				(slider.settings.slideWidth > wrapWidth && !slider.carousel) ||
				slider.settings.mode == 'vertical'){
				newElWidth = wrapWidth;
			// if carousel, use the thresholds to determine the width
			}else if(slider.settings.maxSlides > 1 && slider.settings.mode == 'horizontal'){
				if(wrapWidth > slider.maxThreshold){
					// newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.maxSlides - 1))) / slider.settings.maxSlides;
				}else if(wrapWidth < slider.minThreshold){
					newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.minSlides - 1))) / slider.settings.minSlides;
				}
			}
			return newElWidth;
		}
		
		/**
		 * Returns the number of slides currently visible in the viewport (includes partially visible slides)
		 */
		var getNumberSlidesShowing = function(){
			var slidesShowing = 1;
			if(slider.settings.mode == 'horizontal' && slider.settings.slideWidth > 0){
				// if viewport is smaller than minThreshold, return minSlides
				if(slider.viewport.width() < slider.minThreshold){
					slidesShowing = slider.settings.minSlides;
				// if viewport is larger than minThreshold, return maxSlides
				}else if(slider.viewport.width() > slider.maxThreshold){
					slidesShowing = slider.settings.maxSlides;
				// if viewport is between min / max thresholds, divide viewport width by first child width
				}else{
					var childWidth = slider.children.first().width();
					slidesShowing = Math.floor(slider.viewport.width() / childWidth);
				}
			// if "vertical" mode, slides showing will always be minSlides
			}else if(slider.settings.mode == 'vertical'){
				slidesShowing = slider.settings.minSlides;
			}
			return slidesShowing;
		}
		
		/**
		 * Returns the number of pages (one full viewport of slides is one "page")
		 */
		var getPagerQty = function(){
			var pagerQty = 0;
			// if moveSlides is specified by the user
			if(slider.settings.moveSlides > 0){
				if(slider.settings.infiniteLoop){
					pagerQty = slider.children.length / getMoveBy();
				}else{
					// use a while loop to determine pages
					var breakPoint = 0;
					var counter = 0
					// when breakpoint goes above children length, counter is the number of pages
					while (breakPoint < slider.children.length){
						++pagerQty;
						breakPoint = counter + getNumberSlidesShowing();
						counter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();
					}
				}
			// if moveSlides is 0 (auto) divide children length by sides showing, then round up
			}else{
				pagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());
			}
			return pagerQty;
		}
		
		/**
		 * Returns the number of indivual slides by which to shift the slider
		 */
		var getMoveBy = function(){
			// if moveSlides was set by the user and moveSlides is less than number of slides showing
			if(slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()){
				return slider.settings.moveSlides;
			}
			// if moveSlides is 0 (auto)
			return getNumberSlidesShowing();
		}
		
		/**
		 * Sets the slider's (el) left or top position
		 */
		var setSlidePosition = function(){
			// if last slide, not infinite loop, and number of children is larger than specified maxSlides
			if(slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop){
				if (slider.settings.mode == 'horizontal'){
					// get the last child's position
					var lastChild = slider.children.last();
					var position = lastChild.position();
					// set the left position
					setPositionProperty(-(position.left - (slider.viewport.width() - lastChild.width())), 'reset', 0);
				}else if(slider.settings.mode == 'vertical'){
					// get the last showing index's position
					var lastShowingIndex = slider.children.length - slider.settings.minSlides;
					var position = slider.children.eq(lastShowingIndex).position();
					// set the top position
					setPositionProperty(-position.top, 'reset', 0);
				}
			// if not last slide
			}else{
				// get the position of the first showing slide
				var position = slider.children.eq(slider.active.index * getMoveBy()).position();
				// check for last slide
				if (slider.active.index == getPagerQty() - 1) slider.active.last = true;
				// set the repective position
				if (position != undefined){
					if (slider.settings.mode == 'horizontal') setPositionProperty(-position.left, 'reset', 0);
					else if (slider.settings.mode == 'vertical') setPositionProperty(-position.top, 'reset', 0);
				}
			}
		}
		
		/**
		 * Sets the el's animating property position (which in turn will sometimes animate el).
		 * If using CSS, sets the transform property. If not using CSS, sets the top / left property.
		 *
		 * @param value (int) 
		 *  - the animating property's value
		 *
		 * @param type (string) 'slider', 'reset', 'ticker'
		 *  - the type of instance for which the function is being
		 *
		 * @param duration (int) 
		 *  - the amount of time (in ms) the transition should occupy
		 *
		 * @param params (array) optional
		 *  - an optional parameter containing any variables that need to be passed in
		 */
		var setPositionProperty = function(value, type, duration, params){
			// use CSS transform
			if(slider.usingCSS){
				// determine the translate3d value
				var propValue = slider.settings.mode == 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';
				// add the CSS transition-duration
				el.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');
				if(type == 'slide'){
					// set the property value
					el.css(slider.animProp, propValue);
					// bind a callback method - executes when CSS transition completes
					el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){
						// unbind the callback
						el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
						updateAfterSlideTransition();
					});
				}else if(type == 'reset'){
					el.css(slider.animProp, propValue);
				}else if(type == 'ticker'){
					// make the transition use 'linear'
					el.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');
					el.css(slider.animProp, propValue);
					// bind a callback method - executes when CSS transition completes
					el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){
						// unbind the callback
						el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
						// reset the position
						setPositionProperty(params['resetValue'], 'reset', 0);
						// start the loop again
						tickerLoop();
					});
				}
			// use JS animate
			}else{
				var animateObj = {};
				animateObj[slider.animProp] = value;
				if(type == 'slide'){
					el.animate(animateObj, duration, slider.settings.easing, function(){
						updateAfterSlideTransition();
					});
				}else if(type == 'reset'){
					el.css(slider.animProp, value)
				}else if(type == 'ticker'){
					el.animate(animateObj, speed, 'linear', function(){
						setPositionProperty(params['resetValue'], 'reset', 0);
						// run the recursive loop after animation
						tickerLoop();
					});
				}
			}
		}
		
		/**
		 * Populates the pager with proper amount of pages
		 */
		var populatePager = function(){
			var pagerHtml = '';
			var pagerQty = getPagerQty();
			// loop through each pager item
			for(var i=0; i < pagerQty; i++){
				var linkContent = '';
				// if a buildPager function is supplied, use it to get pager link value, else use index + 1
				if(slider.settings.buildPager && $.isFunction(slider.settings.buildPager)){
					linkContent = slider.settings.buildPager(i);
					slider.pagerEl.addClass('bx-custom-pager');
				}else{
					linkContent = i + 1;
					slider.pagerEl.addClass('bx-default-pager');
				}
				// var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;
				// add the markup to the string
				pagerHtml += '<div class="bx-pager-item"><a href="" data-slide-index="' + i + '" class="bx-pager-link">' + linkContent + '</a></div>';
			};
			// populate the pager element with pager links
			slider.pagerEl.html(pagerHtml);
		}
		
		/**
		 * Appends the pager to the controls element
		 */
		var appendPager = function(){
			if(!slider.settings.pagerCustom){
				// create the pager DOM element
				slider.pagerEl = $('<div class="bx-pager" />');
				// if a pager selector was supplied, populate it with the pager
				if(slider.settings.pagerSelector){
					$(slider.settings.pagerSelector).html(slider.pagerEl);
				// if no pager selector was supplied, add it after the wrapper
				}else{
					slider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);
				}
				// populate the pager
				populatePager();
			}else{
				slider.pagerEl = $(slider.settings.pagerCustom);
			}
			// assign the pager click binding
			slider.pagerEl.delegate('a', 'click', clickPagerBind);
		}
		
		/**
		 * Appends prev / next controls to the controls element
		 */
		var appendControls = function(){
			slider.controls.next = $('<a class="bx-next" href="">' + slider.settings.nextText + '</a>');
			slider.controls.prev = $('<a class="bx-prev" href="">' + slider.settings.prevText + '</a>');
			// bind click actions to the controls
			slider.controls.next.bind('click', clickNextBind);
			slider.controls.prev.bind('click', clickPrevBind);
			// if nextSlector was supplied, populate it
			if(slider.settings.nextSelector){
				$(slider.settings.nextSelector).append(slider.controls.next);
			}
			// if prevSlector was supplied, populate it
			if(slider.settings.prevSelector){
				$(slider.settings.prevSelector).append(slider.controls.prev);
			}
			// if no custom selectors were supplied
			if(!slider.settings.nextSelector && !slider.settings.prevSelector){
				// add the controls to the DOM
				slider.controls.directionEl = $('<div class="bx-controls-direction" />');
				// add the control elements to the directionEl
				slider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);
				// slider.viewport.append(slider.controls.directionEl);
				slider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);
			}
		}
		
		/**
		 * Appends start / stop auto controls to the controls element
		 */
		var appendControlsAuto = function(){
			slider.controls.start = $('<div class="bx-controls-auto-item"><a class="bx-start" href="">' + slider.settings.startText + '</a></div>');
			slider.controls.stop = $('<div class="bx-controls-auto-item"><a class="bx-stop" href="">' + slider.settings.stopText + '</a></div>');
			// add the controls to the DOM
			slider.controls.autoEl = $('<div class="bx-controls-auto" />');
			// bind click actions to the controls
			slider.controls.autoEl.delegate('.bx-start', 'click', clickStartBind);
			slider.controls.autoEl.delegate('.bx-stop', 'click', clickStopBind);
			// if autoControlsCombine, insert only the "start" control
			if(slider.settings.autoControlsCombine){
				slider.controls.autoEl.append(slider.controls.start);
			// if autoControlsCombine is false, insert both controls
			}else{
				slider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);
			}
			// if auto controls selector was supplied, populate it with the controls
			if(slider.settings.autoControlsSelector){
				$(slider.settings.autoControlsSelector).html(slider.controls.autoEl);
			// if auto controls selector was not supplied, add it after the wrapper
			}else{
				slider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);
			}
			// update the auto controls
			updateAutoControls(slider.settings.autoStart ? 'stop' : 'start');
		}
		
		/**
		 * Appends image captions to the DOM
		 */
		var appendCaptions = function(){
			// cycle through each child
			slider.children.each(function(index){
				// get the image title attribute
				var title = $(this).find('img:first').attr('title');
				// append the caption
				if (title != undefined) $(this).append('<div class="bx-caption"><span>' + title + '</span></div>');
			});
		}
		
		/**
		 * Click next binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickNextBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			el.goToNextSlide();
			e.preventDefault();
		}
		
		/**
		 * Click prev binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickPrevBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			el.goToPrevSlide();
			e.preventDefault();
		}
		
		/**
		 * Click start binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickStartBind = function(e){
			el.startAuto();
			e.preventDefault();
		}
		
		/**
		 * Click stop binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickStopBind = function(e){
			el.stopAuto();
			e.preventDefault();
		}

		/**
		 * Click pager binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickPagerBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			var pagerLink = $(e.currentTarget);
			var pagerIndex = parseInt(pagerLink.attr('data-slide-index'));
			// if clicked pager link is not active, continue with the goToSlide call
			if(pagerIndex != slider.active.index) el.goToSlide(pagerIndex);
			e.preventDefault();
		}
		
		/**
		 * Updates the pager links with an active class
		 *
		 * @param slideIndex (int) 
		 *  - index of slide to make active
		 */
		var updatePagerActive = function(slideIndex){
			// if "short" pager type
			if(slider.settings.pagerType == 'short'){
				slider.pagerEl.html((slideIndex + 1) + slider.settings.pagerShortSeparator + slider.children.length);
				return;
			}
			// remove all pager active classes
			slider.pagerEl.find('a').removeClass('active');
			// apply the active class for all pagers
			slider.pagerEl.each(function(i, el) { $(el).find('a').eq(slideIndex).addClass('active'); });
		}
		
		/**
		 * Performs needed actions after a slide transition
		 */
		var updateAfterSlideTransition = function(){
			// if infinte loop is true
			if(slider.settings.infiniteLoop){
				var position = '';
				// first slide
				if(slider.active.index == 0){
					// set the new position
					position = slider.children.eq(0).position();
				// carousel, last slide
				}else if(slider.active.index == getPagerQty() - 1 && slider.carousel){
					position = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();
				// last slide
				}else if(slider.active.index == slider.children.length - 1){
					position = slider.children.eq(slider.children.length - 1).position();
				}
				if (slider.settings.mode == 'horizontal') { setPositionProperty(-position.left, 'reset', 0);; }
				else if (slider.settings.mode == 'vertical') { setPositionProperty(-position.top, 'reset', 0);; }
			}
			// declare that the transition is complete
			slider.working = false;
			// onSlideAfter callback
			slider.settings.onSlideAfter(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
		}
		
		/**
		 * Updates the auto controls state (either active, or combined switch)
		 *
		 * @param state (string) "start", "stop"
		 *  - the new state of the auto show
		 */
		var updateAutoControls = function(state){
			// if autoControlsCombine is true, replace the current control with the new state 
			if(slider.settings.autoControlsCombine){
				slider.controls.autoEl.html(slider.controls[state]);
			// if autoControlsCombine is false, apply the "active" class to the appropriate control 
			}else{
				slider.controls.autoEl.find('a').removeClass('active');
				slider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');
			}
		}
		
		/**
		 * Updates the direction controls (checks if either should be hidden)
		 */
		var updateDirectionControls = function(){
			if(getPagerQty() == 1){
				slider.controls.prev.addClass('disabled');
				slider.controls.next.addClass('disabled');
			}else if(!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd){
				// if first slide
				if (slider.active.index == 0){
					slider.controls.prev.addClass('disabled');
					slider.controls.next.removeClass('disabled');
				// if last slide
				}else if(slider.active.index == getPagerQty() - 1){
					slider.controls.next.addClass('disabled');
					slider.controls.prev.removeClass('disabled');
				// if any slide in the middle
				}else{
					slider.controls.prev.removeClass('disabled');
					slider.controls.next.removeClass('disabled');
				}
			}
		}
		
		/**
		 * Initialzes the auto process
		 */
		var initAuto = function(){
			// if autoDelay was supplied, launch the auto show using a setTimeout() call
			if(slider.settings.autoDelay > 0){
				var timeout = setTimeout(el.startAuto, slider.settings.autoDelay);
			// if autoDelay was not supplied, start the auto show normally
			}else{
				el.startAuto();
			}
			// if autoHover is requested
			if(slider.settings.autoHover){
				// on el hover
				el.hover(function(){
					// if the auto show is currently playing (has an active interval)
					if(slider.interval){
						// stop the auto show and pass true agument which will prevent control update
						el.stopAuto(true);
						// create a new autoPaused value which will be used by the relative "mouseout" event
						slider.autoPaused = true;
					}
				}, function(){
					// if the autoPaused value was created be the prior "mouseover" event
					if(slider.autoPaused){
						// start the auto show and pass true agument which will prevent control update
						el.startAuto(true);
						// reset the autoPaused value
						slider.autoPaused = null;
					}
				});
			}
		}
		
		/**
		 * Initialzes the ticker process
		 */
		var initTicker = function(){
			var startPosition = 0;
			// if autoDirection is "next", append a clone of the entire slider
			if(slider.settings.autoDirection == 'next'){
				el.append(slider.children.clone().addClass('bx-clone'));
			// if autoDirection is "prev", prepend a clone of the entire slider, and set the left position
			}else{
				el.prepend(slider.children.clone().addClass('bx-clone'));
				var position = slider.children.first().position();
				startPosition = slider.settings.mode == 'horizontal' ? -position.left : -position.top;
			}
			setPositionProperty(startPosition, 'reset', 0);
			// do not allow controls in ticker mode
			slider.settings.pager = false;
			slider.settings.controls = false;
			slider.settings.autoControls = false;
			// if autoHover is requested
			if(slider.settings.tickerHover && !slider.usingCSS){
				// on el hover
				slider.viewport.hover(function(){
					el.stop();
				}, function(){
					// calculate the total width of children (used to calculate the speed ratio)
					var totalDimens = 0;
					slider.children.each(function(index){
					  totalDimens += slider.settings.mode == 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);
					});
					// calculate the speed ratio (used to determine the new speed to finish the paused animation)
					var ratio = slider.settings.speed / totalDimens;
					// determine which property to use
					var property = slider.settings.mode == 'horizontal' ? 'left' : 'top';
					// calculate the new speed
					var newSpeed = ratio * (totalDimens - (Math.abs(parseInt(el.css(property)))));
					tickerLoop(newSpeed);
				});
			}
			// start the ticker loop
			tickerLoop();
		}
		
		/**
		 * Runs a continuous loop, news ticker-style
		 */
		var tickerLoop = function(resumeSpeed){
			speed = resumeSpeed ? resumeSpeed : slider.settings.speed;
			var position = {left: 0, top: 0};
			var reset = {left: 0, top: 0};
			// if "next" animate left position to last child, then reset left to 0
			if(slider.settings.autoDirection == 'next'){
				position = el.find('.bx-clone').first().position();
			// if "prev" animate left position to 0, then reset left to first non-clone child
			}else{
				reset = slider.children.first().position();
			}
			var animateProperty = slider.settings.mode == 'horizontal' ? -position.left : -position.top;
			var resetValue = slider.settings.mode == 'horizontal' ? -reset.left : -reset.top;
			var params = {resetValue: resetValue};
			setPositionProperty(animateProperty, 'ticker', speed, params);
		}
		
		/**
		 * Initializes touch events
		 */
		var initTouch = function(){
			// initialize object to contain all touch values
			slider.touch = {
				start: {x: 0, y: 0},
				end: {x: 0, y: 0}
			}
			slider.viewport.bind('touchstart', onTouchStart);
		}
		
		/**
		 * Event handler for "touchstart"
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var onTouchStart = function(e){
			if(slider.working){
				e.preventDefault();
			}else{
				// record the original position when touch starts
				slider.touch.originalPos = el.position();
				var orig = e.originalEvent;
				// record the starting touch x, y coordinates
				slider.touch.start.x = orig.changedTouches[0].pageX;
				slider.touch.start.y = orig.changedTouches[0].pageY;
				// bind a "touchmove" event to the viewport
				slider.viewport.bind('touchmove', onTouchMove);
				// bind a "touchend" event to the viewport
				slider.viewport.bind('touchend', onTouchEnd);
			}
		}
		
		/**
		 * Event handler for "touchmove"
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var onTouchMove = function(e){
			var orig = e.originalEvent;
			// if scrolling on y axis, do not prevent default
			var xMovement = Math.abs(orig.changedTouches[0].pageX - slider.touch.start.x);
			var yMovement = Math.abs(orig.changedTouches[0].pageY - slider.touch.start.y);
			// x axis swipe
			if((xMovement * 3) > yMovement && slider.settings.preventDefaultSwipeX){
				e.preventDefault();
			// y axis swipe
			}else if((yMovement * 3) > xMovement && slider.settings.preventDefaultSwipeY){
				e.preventDefault();
			}
			if(slider.settings.mode != 'fade' && slider.settings.oneToOneTouch){
				var value = 0;
				// if horizontal, drag along x axis
				if(slider.settings.mode == 'horizontal'){
					var change = orig.changedTouches[0].pageX - slider.touch.start.x;
					value = slider.touch.originalPos.left + change;
				// if vertical, drag along y axis
				}else{
					var change = orig.changedTouches[0].pageY - slider.touch.start.y;
					value = slider.touch.originalPos.top + change;
				}
				setPositionProperty(value, 'reset', 0);
			}
		}
		
		/**
		 * Event handler for "touchend"
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var onTouchEnd = function(e){
			slider.viewport.unbind('touchmove', onTouchMove);
			var orig = e.originalEvent;
			var value = 0;
			// record end x, y positions
			slider.touch.end.x = orig.changedTouches[0].pageX;
			slider.touch.end.y = orig.changedTouches[0].pageY;
			// if fade mode, check if absolute x distance clears the threshold
			if(slider.settings.mode == 'fade'){
				var distance = Math.abs(slider.touch.start.x - slider.touch.end.x);
				if(distance >= slider.settings.swipeThreshold){
					slider.touch.start.x > slider.touch.end.x ? el.goToNextSlide() : el.goToPrevSlide();
					el.stopAuto();
				}
			// not fade mode
			}else{
				var distance = 0;
				// calculate distance and el's animate property
				if(slider.settings.mode == 'horizontal'){
					distance = slider.touch.end.x - slider.touch.start.x;
					value = slider.touch.originalPos.left;
				}else{
					distance = slider.touch.end.y - slider.touch.start.y;
					value = slider.touch.originalPos.top;
				}
				// if not infinite loop and first / last slide, do not attempt a slide transition
				if(!slider.settings.infiniteLoop && ((slider.active.index == 0 && distance > 0) || (slider.active.last && distance < 0))){
					setPositionProperty(value, 'reset', 200);
				}else{
					// check if distance clears threshold
					if(Math.abs(distance) >= slider.settings.swipeThreshold){
						distance < 0 ? el.goToNextSlide() : el.goToPrevSlide();
						el.stopAuto();
					}else{
						// el.animate(property, 200);
						setPositionProperty(value, 'reset', 200);
					}
				}
			}
			slider.viewport.unbind('touchend', onTouchEnd);
		}

		/**
		 * Window resize event callback
		 */
		var resizeWindow = function(e){
			// get the new window dimens (again, thank you IE)
			var windowWidthNew = $(window).width();
			var windowHeightNew = $(window).height();
			// make sure that it is a true window resize
			// *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements
			// are resized. Can you just die already?*
			if(windowWidth != windowWidthNew || windowHeight != windowHeightNew){
				// set the new window dimens
				windowWidth = windowWidthNew;
				windowHeight = windowHeightNew;
				// update all dynamic elements
				el.redrawSlider();
			}
		}
		
		/**
		 * ===================================================================================
		 * = PUBLIC FUNCTIONS
		 * ===================================================================================
		 */
		
		/**
		 * Performs slide transition to the specified slide
		 *
		 * @param slideIndex (int) 
		 *  - the destination slide's index (zero-based)
		 *
		 * @param direction (string) 
		 *  - INTERNAL USE ONLY - the direction of travel ("prev" / "next")
		 */
		el.goToSlide = function(slideIndex, direction){
			// if plugin is currently in motion, ignore request
			if(slider.working || slider.active.index == slideIndex) return;
			// declare that plugin is in motion
			slider.working = true;
			// store the old index
			slider.oldIndex = slider.active.index;
			// if slideIndex is less than zero, set active index to last child (this happens during infinite loop)
			if(slideIndex < 0){
				slider.active.index = getPagerQty() - 1;
			// if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)
			}else if(slideIndex >= getPagerQty()){
				slider.active.index = 0;
			// set active index to requested slide
			}else{
				slider.active.index = slideIndex;
			}
			// onSlideBefore, onSlideNext, onSlidePrev callbacks
			slider.settings.onSlideBefore(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			if(direction == 'next'){
				slider.settings.onSlideNext(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			}else if(direction == 'prev'){
				slider.settings.onSlidePrev(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			}
			// check if last slide
			slider.active.last = slider.active.index >= getPagerQty() - 1;
			// update the pager with active class
			if(slider.settings.pager) updatePagerActive(slider.active.index);
			// // check for direction control update
			if(slider.settings.controls) updateDirectionControls();
			// if slider is set to mode: "fade"
			if(slider.settings.mode == 'fade'){
				// if adaptiveHeight is true and next height is different from current height, animate to the new height
				if(slider.settings.adaptiveHeight && slider.viewport.height() != getViewportHeight()){
					slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
				}
				// fade out the visible child and reset its z-index value
				slider.children.filter(':visible').fadeOut(slider.settings.speed).css({zIndex: 0});
				// fade in the newly requested slide
				slider.children.eq(slider.active.index).css('zIndex', 51).fadeIn(slider.settings.speed, function(){
					$(this).css('zIndex', 50);
					updateAfterSlideTransition();
				});
			// slider mode is not "fade"
			}else{
				// if adaptiveHeight is true and next height is different from current height, animate to the new height
				if(slider.settings.adaptiveHeight && slider.viewport.height() != getViewportHeight()){
					slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
				}
				var moveBy = 0;
				var position = {left: 0, top: 0};
				// if carousel and not infinite loop
				if(!slider.settings.infiniteLoop && slider.carousel && slider.active.last){
					if(slider.settings.mode == 'horizontal'){
						// get the last child position
						var lastChild = slider.children.eq(slider.children.length - 1);
						position = lastChild.position();
						// calculate the position of the last slide
						moveBy = slider.viewport.width() - lastChild.outerWidth();
					}else{
						// get last showing index position
						var lastShowingIndex = slider.children.length - slider.settings.minSlides;
						position = slider.children.eq(lastShowingIndex).position();
					}
					// horizontal carousel, going previous while on first slide (infiniteLoop mode)
				}else if(slider.carousel && slider.active.last && direction == 'prev'){
					// get the last child position
					var eq = slider.settings.moveSlides == 1 ? slider.settings.maxSlides - getMoveBy() : ((getPagerQty() - 1) * getMoveBy()) - (slider.children.length - slider.settings.maxSlides);
					var lastChild = el.children('.bx-clone').eq(eq);
					position = lastChild.position();
				// if infinite loop and "Next" is clicked on the last slide
				}else if(direction == 'next' && slider.active.index == 0){
					// get the last clone position
					position = el.find('> .bx-clone').eq(slider.settings.maxSlides).position();
					slider.active.last = false;
				// normal non-zero requests
				}else if(slideIndex >= 0){
					var requestEl = slideIndex * getMoveBy();
					position = slider.children.eq(requestEl).position();
				}
				
				/* If the position doesn't exist 
				 * (e.g. if you destroy the slider on a next click),
				 * it doesn't throw an error.
				 */
				if ("undefined" !== typeof(position)) {
					var value = slider.settings.mode == 'horizontal' ? -(position.left - moveBy) : -position.top;
					// plugin values to be animated
					setPositionProperty(value, 'slide', slider.settings.speed);
				}
			}
		}
		
		/**
		 * Transitions to the next slide in the show
		 */
		el.goToNextSlide = function(){
			// if infiniteLoop is false and last page is showing, disregard call
			if (!slider.settings.infiniteLoop && slider.active.last) return;
			var pagerIndex = parseInt(slider.active.index) + 1;
			el.goToSlide(pagerIndex, 'next');
		}
		
		/**
		 * Transitions to the prev slide in the show
		 */
		el.goToPrevSlide = function(){
			// if infiniteLoop is false and last page is showing, disregard call
			if (!slider.settings.infiniteLoop && slider.active.index == 0) return;
			var pagerIndex = parseInt(slider.active.index) - 1;
			el.goToSlide(pagerIndex, 'prev');
		}
		
		/**
		 * Starts the auto show
		 *
		 * @param preventControlUpdate (boolean) 
		 *  - if true, auto controls state will not be updated
		 */
		el.startAuto = function(preventControlUpdate){
			// if an interval already exists, disregard call
			if(slider.interval) return;
			// create an interval
			slider.interval = setInterval(function(){
				slider.settings.autoDirection == 'next' ? el.goToNextSlide() : el.goToPrevSlide();
			}, slider.settings.pause);
			// if auto controls are displayed and preventControlUpdate is not true
			if (slider.settings.autoControls && preventControlUpdate != true) updateAutoControls('stop');
		}
		
		/**
		 * Stops the auto show
		 *
		 * @param preventControlUpdate (boolean) 
		 *  - if true, auto controls state will not be updated
		 */
		el.stopAuto = function(preventControlUpdate){
			// if no interval exists, disregard call
			if(!slider.interval) return;
			// clear the interval
			clearInterval(slider.interval);
			slider.interval = null;
			// if auto controls are displayed and preventControlUpdate is not true
			if (slider.settings.autoControls && preventControlUpdate != true) updateAutoControls('start');
		}
		
		/**
		 * Returns current slide index (zero-based)
		 */
		el.getCurrentSlide = function(){
			return slider.active.index;
		}
		
		/**
		 * Returns number of slides in show
		 */
		el.getSlideCount = function(){
			return slider.children.length;
		}

		/**
		 * Update all dynamic slider elements
		 */
		el.redrawSlider = function(){
			// resize all children in ratio to new screen size
			slider.children.add(el.find('.bx-clone')).outerWidth(getSlideWidth());
			// adjust the height
			slider.viewport.css('height', getViewportHeight());
			// update the slide position
			if(!slider.settings.ticker) setSlidePosition();
			// if active.last was true before the screen resize, we want
			// to keep it last no matter what screen size we end on
			if (slider.active.last) slider.active.index = getPagerQty() - 1;
			// if the active index (page) no longer exists due to the resize, simply set the index as last
			if (slider.active.index >= getPagerQty()) slider.active.last = true;
			// if a pager is being displayed and a custom pager is not being used, update it
			if(slider.settings.pager && !slider.settings.pagerCustom){
				populatePager();
				updatePagerActive(slider.active.index);
			}
		}

		/**
		 * Destroy the current instance of the slider (revert everything back to original state)
		 */
		el.destroySlider = function(){
			// don't do anything if slider has already been destroyed
			if(!slider.initialized) return;
			slider.initialized = false;
			$('.bx-clone', this).remove();
			slider.children.removeAttr('style');
			this.removeAttr('style').unwrap().unwrap();
			if(slider.controls.el) slider.controls.el.remove();
			if(slider.controls.next) slider.controls.next.remove();
			if(slider.controls.prev) slider.controls.prev.remove();
			if(slider.pagerEl) slider.pagerEl.remove();
			$('.bx-caption', this).remove();
			if(slider.controls.autoEl) slider.controls.autoEl.remove();
			clearInterval(slider.interval);
			$(window).unbind('resize', resizeWindow);
		}

		/**
		 * Reload the slider (revert all DOM changes, and re-initialize)
		 */
		el.reloadSlider = function(settings){
			if (settings != undefined) options = settings;
			el.destroySlider();
			init();
		}
		
		init();
		
		// returns the current jQuery object
		return this;
	}

})(jQuery);

/*!
 * jQuery imagesLoaded plugin v2.1.0
 * http://github.com/desandro/imagesloaded
 *
 * MIT License. by Paul Irish et al.
 */

/*jshint curly: true, eqeqeq: true, noempty: true, strict: true, undef: true, browser: true */
/*global jQuery: false */

(function(c,n){var l="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";c.fn.imagesLoaded=function(f){function m(){var b=c(i),a=c(h);d&&(h.length?d.reject(e,b,a):d.resolve(e));c.isFunction(f)&&f.call(g,e,b,a)}function j(b,a){b.src===l||-1!==c.inArray(b,k)||(k.push(b),a?h.push(b):i.push(b),c.data(b,"imagesLoaded",{isBroken:a,src:b.src}),o&&d.notifyWith(c(b),[a,e,c(i),c(h)]),e.length===k.length&&(setTimeout(m),e.unbind(".imagesLoaded")))}var g=this,d=c.isFunction(c.Deferred)?c.Deferred():
0,o=c.isFunction(d.notify),e=g.find("img").add(g.filter("img")),k=[],i=[],h=[];c.isPlainObject(f)&&c.each(f,function(b,a){if("callback"===b)f=a;else if(d)d[b](a)});e.length?e.bind("load.imagesLoaded error.imagesLoaded",function(b){j(b.target,"error"===b.type)}).each(function(b,a){var d=a.src,e=c.data(a,"imagesLoaded");if(e&&e.src===d)j(a,e.isBroken);else if(a.complete&&a.naturalWidth!==n)j(a,0===a.naturalWidth||0===a.naturalHeight);else if(a.readyState||a.complete)a.src=l,a.src=d}):m();return d?d.promise(g):
g}})(jQuery);

;(function($, window, document, undefined){
	"use strict";

	Bill.libs.slider = {
		name:'Slider',
		version:'0.1.0',
		nameSpace:Bill.eventNameSpace + '.slider',
		options:{
			adaptiveHeight:true,
			auto:true,
			autoHover:true
		},
		sliders:$(),
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			if(!this.options.init){
				this.on();
			}

			return this.options.init;
		},
		/**
		 * Activates the library
		 */
		on:function(){
			this.sliders = $(this.scope).find('[data-slider]').bxSlider(this.options);

			this.options.init = true;
		},
		/**
		 * De-activates the library
		 */
		off:function(){
			this.sliders.destroySlider();

			this.options.init = false;
		}
	};
})(jQuery, window, document);
/**
 * Bill.tabs
 *
 * Adds tabs functionality
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.libs.tabs = {
		name:'Tabs',
		version:'0.1.0',
		nameSpace:Bill.eventNameSpace + '.tabs',
		options:{
			animSpeed:200,
			animType:'show',
			tabSelector:'tab',
			paneSelector:'pane'
		},
		init:function(scope, method, options){
			this.scope = scope || this.scope;

			if(typeof method === 'object'){
				// method is actually options
				$.extend(true, this.options, method);
			}else if(typeof method === 'string'){
				// call the method and return
				return this[method].call(this, options);
			}

			if(!this.options.init){
				var lib = this;

				this.on();

				$(this.scope).find('[data-tabs]').each(function(){
					var $elm = $(this),
						$tabs,
						$panes;

					if($elm.get(0).nodeName == 'DL'){
						// the tab element is a definition list
						$tabs = $elm.children('dt');
						$panes = $elm.children('dd');

						// loop through and ensure that all of them contain links
						$tabs.each(function(){
							var btn = $(this);
							if(btn.children('a:first').length == 0){
								// dd contains no link
								var pane = btn.next('dd:first'),																		// the tab pane
									id = pane.prop('id') || 'tab-' + (new Date().getTime()) + '-' + Math.floor(Math.random()*10000);	// the pane ID
								// wrap the dt contents in the link (wrapinner doesn't always work here)
								btn.html('<a href="#' + id + '">' + btn.text() + '</a>');
								// assign the ID to the pane
								pane.prop('id', id);
							}
						});

						// add the tabs to the container
						$elm.prepend($tabs);
					}else{
						$tabs = $elm.children(':first');
						var firstType = $tabs.get(0).nodeName;

						if(firstType == 'UL'){
							// first element is a list - we assume it's a list of tab links
							// get a list of the panes
							$panes = $elm.children().not($tabs);
							// set the tabs to the li elements
							$tabs = $tabs.children('li');
						}else{
							// first element isn't a list - assume that tab titles will come from within the content
							var tabHtml = '<ul>';

							// loop through each tabs child and get their headers
							$elm.children().each(function(i){
								// find the first heading element
								var $pane = $(this),																					// the tab pane
									id = $pane.prop('id') || 'tab-' + (new Date().getTime()) + '-' + Math.floor(Math.random()*10000),	// the pane ID
									header = $pane.children('h1,h2,h3,h4,h5,h6').first(),												// the header element
									label = header.length ? header.text() : $pane.attr('data-label') || 'Tab ' + (i+1);

								// ensure that the pane has an ID
								$pane.prop('id', id);
								// add the pane to the list
								$panes = $panes ? $panes.add($pane) : $pane;

								// define the tab text
								tabHtml += '<li>' +
												'<a href="#' + id + '">' + label + '</a>' +
											'</li>';
							});

							tabHtml += '</ul>';
							// add the tabs to the container and return the li elements as tabs
							$tabs = $(tabHtml).prependTo($elm).children('li');
						}
					}

					if($tabs && $tabs.length){
						// tab buttons exist

						// add classes to all of the tabs and panes
						$tabs.addClass(lib.options.tabSelector);
						$panes.addClass(lib.options.paneSelector);

						$tabs = $tabs.children('a');

						// show an active tab
						var animType = lib.options.animType,	// the current animation type
							// check for an active button
							// if a hash has been defined, check for a button matching it,
							// otherwise look for a button with class 'active'
							activeBtn = location.hash ?
								$($tabs.filter('[href="' + location.hash + '"]:first')[0] || $tabs.filter('.active:first')[0])
								:
								$tabs.filter('.active:first');
						// if no tab buttons have a class of active, just go with the first tab
						activeBtn = !activeBtn.length ? $tabs.first() : activeBtn;

						// set no animation type, so that the tab appears immediately
						lib.options.animType = null;

						// trigger the click event, to show only the active pane
						activeBtn.click();

						// reset the animation type
						lib.options.animType = animType;
					}
				});

				this.options.init = true;
			}

			return this.options.init;
		},
		/**
		 * Activates the plugin
		 */
		on:function(){
			var lib = this;

			/**
			 * Adds click handler for tab titles
			 */
			$(this.scope).on('click' + this.nameSpace, '[data-tabs] .' + lib.options.tabSelector + ' a', function(e){
				var $tab = $(this),	// the clicked tab
					$container = $tab.closest('[data-tabs]'),						// the tab/pane container
					$tabs = $container.find('.' + lib.options.tabSelector + ' a'),	// list of tabs
					$panes = $container.find('.' + lib.options.paneSelector),		// list of panes
					$pane = $panes.filter($tab.attr('href'));						// pane the clicked tab corresponds to

				// stop any active animation
				$panes.stop(true, true);

				// remove active class on all tabs
				$tabs.removeClass('active');
				// add the active class to the current title
				$tab.addClass('active');

				switch(lib.options.animType || 'show'){
					// animate
					case 'slide':
						$panes.not($pane).slideUp(lib.options.animSpeed);
						$pane.slideDown(lib.options.animSpeed);
					break;
					case 'fade':
						$panes.hide();
						$pane.fadeIn(lib.options.animSpeed);
					break;
					default:
						// no recognised (or 'show') animation - just show
						$panes.hide();
						$pane.show();
					break;
				}

				// stop the default click event
				e.preventDefault();
			});
		},
		/**
		 * De-activates the plugin
		 */
		off:function(){
			$(this.scope).off(this.nameSpace);
		}
	};
})(jQuery, window, document);


/**
 * Extensions
 */
/**
 * Bill.extensions.querystring
 *
 * Adds jQuery function for getting the URL query strings.
 * If `name` is defined, then it will return that named value
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.extensions.querystring = {
		name:'Querystring',
		version:'0.1.0',
		init:function(name){
			var queryString = window.location.search.substr(1);
			if(!queryString){
				// no query string
				return name ? null : {};
			}

			// check for a cached query string
			var $window = $(window),
				cache = $window.data('queryString');
			cache = $.extend(cache, {}); // ensure that the cache is an object

			if(!cache[queryString]){
				// no cache exists for the current query string

				// get the query string and split by &
				var queryVars = queryString.split('&'),
					arrayCheck = /^([^\[]+)((\[[^\]]*\])+)$/,
					arrayKeyCheck = /\[[^\]]*\]/g;

				// the query string variable
				cache[queryString] = {};

				// loop through each key=>value pair
				for(var i = 0; i < queryVars.length; i++){
					if(queryVars[i]){
						var variable = queryVars[i].split('='),
							key = decodeURIComponent(variable[0]),
							value = (typeof variable[1] == 'string') ? decodeURIComponent(variable[1].replace(/\+/g, ' ')) : undefined;

						// check if the key is an array
						if(arrayCheck.test(key)){
							// key is an array
							key = RegExp.$1;	// the key

							// ensure that they key is initialised as a variable of the cache
							cache[queryString][key] = cache[queryString][key] || {length: 0};

							var arrayNames = '',							// string of previous array key names
								arrays = RegExp.$2.match(arrayKeyCheck),	// list of array key names
								arrayLen = arrays.length;					// count of array key names
							// loop through the array key names and create the variables
							$.each(arrays, function(i, subKey){
								// determine the key name - if it is a string, we use it, if it is empty we calculate the numeric number, from the current array length
								subKey = (subKey && (subKey != '[]')) ? '"' + subKey.replace(/\[|\]/g, '') + '"' : eval('cache[queryString][key]' + arrayNames + '.length');

								// create the variable - I KNOW that using eval is horrible, but it's the best solution I could come up with quickly.
								eval('cache[queryString][key]' + arrayNames + '[' + subKey + '] = cache[queryString][key]' + arrayNames + '[' + subKey + '] || ' + ((i+1 == arrayLen) ? 'value' : '[]'));

								// add the array key to the list
								arrayNames += !isNaN(subKey) ? '' : '[' + subKey + ']';
							});

							//cache[queryString][key][RegExp.$2 ? RegExp.$2 : cache[queryString][key].length] = value;
							cache[queryString][key].length++;
						}else{
							cache[queryString][key] = value;
						}
					}
				}

				// cache the result
				$window.data('queryString', cache);
			}

			return name ? cache[queryString][name] : cache[queryString];
		}
	};
})(jQuery, window, document);
/**
 * Bill.extensions.viewport
 *
 * Returns the viewport size and allows checking
 * whether the screen is small, medium or large
 */
;(function($, window, document, undefined){
	"use strict";

	Bill.extensions.viewport = {
		width:function(){
			return Math.max($(window).innerWidth(), window.innerWidth);
		},
		height:function(){
			return Math.max($(window).innerHeight(), window.innerHeight);
		},
		size:function(){
			return {
				width:this.width(),
				height:this.height()
			};
		},
		isSmall:function(){
			return this.width() <= 767;
		},
		isMedium:function(){
			var width = this.width();
			return (width > 767) && (width < 980);
		},
		isLarge:function(){
			return this.width() >= 980;
		}
	}
})(jQuery, window, document);
